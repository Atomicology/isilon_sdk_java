/*
 * Isilon SDK
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.Error;
import io.swagger.client.model.HistogramStatBy;
import io.swagger.client.model.ResultDirectories;
import io.swagger.client.model.ResultHistogram;
import io.swagger.client.model.ResultTopDirs;
import io.swagger.client.model.ResultTopFiles;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FsaResultsApi {
    private ApiClient apiClient;

    public FsaResultsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public FsaResultsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for getHistogramStatBy
     * @param id  (required)
     * @param stat  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getHistogramStatByCall(String id, String stat, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/histogram/{Stat}/by"
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()))
            .replaceAll("\\{" + "Stat" + "\\}", apiClient.escapeString(stat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getHistogramStatByValidateBeforeCall(String id, String stat, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getHistogramStatBy(Async)");
        }
        
        // verify the required parameter 'stat' is set
        if (stat == null) {
            throw new ApiException("Missing the required parameter 'stat' when calling getHistogramStatBy(Async)");
        }
        

        com.squareup.okhttp.Call call = getHistogramStatByCall(id, stat, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param stat  (required)
     * @return HistogramStatBy
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HistogramStatBy getHistogramStatBy(String id, String stat) throws ApiException {
        ApiResponse<HistogramStatBy> resp = getHistogramStatByWithHttpInfo(id, stat);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param stat  (required)
     * @return ApiResponse&lt;HistogramStatBy&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HistogramStatBy> getHistogramStatByWithHttpInfo(String id, String stat) throws ApiException {
        com.squareup.okhttp.Call call = getHistogramStatByValidateBeforeCall(id, stat, null, null);
        Type localVarReturnType = new TypeToken<HistogramStatBy>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param stat  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getHistogramStatByAsync(String id, String stat, final ApiCallback<HistogramStatBy> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getHistogramStatByValidateBeforeCall(id, stat, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HistogramStatBy>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getHistogramStatByBreakout
     * @param histogramStatByBreakout This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param stat  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param limit Limit the number of breakout results. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getHistogramStatByBreakoutCall(String histogramStatByBreakout, String id, String stat, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, Integer limit, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/histogram/{Stat}/by/{HistogramStatByBreakout}"
            .replaceAll("\\{" + "HistogramStatByBreakout" + "\\}", apiClient.escapeString(histogramStatByBreakout.toString()))
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()))
            .replaceAll("\\{" + "Stat" + "\\}", apiClient.escapeString(stat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (directoryFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("directory_filter", directoryFilter));
        if (attributeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("attribute_filter", attributeFilter));
        if (nodePoolFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("node_pool_filter", nodePoolFilter));
        if (diskPoolFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disk_pool_filter", diskPoolFilter));
        if (tierFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("tier_filter", tierFilter));
        if (compReport != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("comp_report", compReport));
        if (logSizeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("log_size_filter", logSizeFilter));
        if (physSizeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("phys_size_filter", physSizeFilter));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (pathExtFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path_ext_filter", pathExtFilter));
        if (ctimeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ctime_filter", ctimeFilter));
        if (atimeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("atime_filter", atimeFilter));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getHistogramStatByBreakoutValidateBeforeCall(String histogramStatByBreakout, String id, String stat, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, Integer limit, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'histogramStatByBreakout' is set
        if (histogramStatByBreakout == null) {
            throw new ApiException("Missing the required parameter 'histogramStatByBreakout' when calling getHistogramStatByBreakout(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getHistogramStatByBreakout(Async)");
        }
        
        // verify the required parameter 'stat' is set
        if (stat == null) {
            throw new ApiException("Missing the required parameter 'stat' when calling getHistogramStatByBreakout(Async)");
        }
        

        com.squareup.okhttp.Call call = getHistogramStatByBreakoutCall(histogramStatByBreakout, id, stat, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, limit, pathExtFilter, ctimeFilter, atimeFilter, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID.
     * @param histogramStatByBreakout This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param stat  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param limit Limit the number of breakout results. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @return HistogramStatBy
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public HistogramStatBy getHistogramStatByBreakout(String histogramStatByBreakout, String id, String stat, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, Integer limit, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter) throws ApiException {
        ApiResponse<HistogramStatBy> resp = getHistogramStatByBreakoutWithHttpInfo(histogramStatByBreakout, id, stat, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, limit, pathExtFilter, ctimeFilter, atimeFilter);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID.
     * @param histogramStatByBreakout This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param stat  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param limit Limit the number of breakout results. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @return ApiResponse&lt;HistogramStatBy&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<HistogramStatBy> getHistogramStatByBreakoutWithHttpInfo(String histogramStatByBreakout, String id, String stat, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, Integer limit, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter) throws ApiException {
        com.squareup.okhttp.Call call = getHistogramStatByBreakoutValidateBeforeCall(histogramStatByBreakout, id, stat, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, limit, pathExtFilter, ctimeFilter, atimeFilter, null, null);
        Type localVarReturnType = new TypeToken<HistogramStatBy>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID.
     * @param histogramStatByBreakout This resource retrieves a histogram breakout for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param stat  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param limit Limit the number of breakout results. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getHistogramStatByBreakoutAsync(String histogramStatByBreakout, String id, String stat, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, Integer limit, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter, final ApiCallback<HistogramStatBy> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getHistogramStatByBreakoutValidateBeforeCall(histogramStatByBreakout, id, stat, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, limit, pathExtFilter, ctimeFilter, atimeFilter, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<HistogramStatBy>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultDirectories
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param path Primary directory path to report usage information, which may be specified instead of a LIN. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultDirectoriesCall(String id, String sort, String path, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/directories"
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        if (path != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path", path));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (compReport != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("comp_report", compReport));
        if (dir != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("dir", dir));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultDirectoriesValidateBeforeCall(String id, String sort, String path, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultDirectories(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultDirectoriesCall(id, sort, path, limit, compReport, dir, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves directory information. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param path Primary directory path to report usage information, which may be specified instead of a LIN. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ResultDirectories
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultDirectories getResultDirectories(String id, String sort, String path, Integer limit, Integer compReport, String dir) throws ApiException {
        ApiResponse<ResultDirectories> resp = getResultDirectoriesWithHttpInfo(id, sort, path, limit, compReport, dir);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves directory information. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param path Primary directory path to report usage information, which may be specified instead of a LIN. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ApiResponse&lt;ResultDirectories&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultDirectories> getResultDirectoriesWithHttpInfo(String id, String sort, String path, Integer limit, Integer compReport, String dir) throws ApiException {
        com.squareup.okhttp.Call call = getResultDirectoriesValidateBeforeCall(id, sort, path, limit, compReport, dir, null, null);
        Type localVarReturnType = new TypeToken<ResultDirectories>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves directory information. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param path Primary directory path to report usage information, which may be specified instead of a LIN. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultDirectoriesAsync(String id, String sort, String path, Integer limit, Integer compReport, String dir, final ApiCallback<ResultDirectories> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultDirectoriesValidateBeforeCall(id, sort, path, limit, compReport, dir, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultDirectories>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultDirectory
     * @param resultDirectoryId This resource retrieves directory information. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultDirectoryCall(Integer resultDirectoryId, String id, String sort, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/directories/{ResultDirectoryId}"
            .replaceAll("\\{" + "ResultDirectoryId" + "\\}", apiClient.escapeString(resultDirectoryId.toString()))
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (compReport != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("comp_report", compReport));
        if (dir != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("dir", dir));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultDirectoryValidateBeforeCall(Integer resultDirectoryId, String id, String sort, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'resultDirectoryId' is set
        if (resultDirectoryId == null) {
            throw new ApiException("Missing the required parameter 'resultDirectoryId' when calling getResultDirectory(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultDirectory(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultDirectoryCall(resultDirectoryId, id, sort, limit, compReport, dir, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves directory information. ID in the resource path is the result set ID.
     * @param resultDirectoryId This resource retrieves directory information. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ResultDirectories
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultDirectories getResultDirectory(Integer resultDirectoryId, String id, String sort, Integer limit, Integer compReport, String dir) throws ApiException {
        ApiResponse<ResultDirectories> resp = getResultDirectoryWithHttpInfo(resultDirectoryId, id, sort, limit, compReport, dir);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves directory information. ID in the resource path is the result set ID.
     * @param resultDirectoryId This resource retrieves directory information. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ApiResponse&lt;ResultDirectories&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultDirectories> getResultDirectoryWithHttpInfo(Integer resultDirectoryId, String id, String sort, Integer limit, Integer compReport, String dir) throws ApiException {
        com.squareup.okhttp.Call call = getResultDirectoryValidateBeforeCall(resultDirectoryId, id, sort, limit, compReport, dir, null, null);
        Type localVarReturnType = new TypeToken<ResultDirectories>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves directory information. ID in the resource path is the result set ID.
     * @param resultDirectoryId This resource retrieves directory information. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param limit Limit the number of reported subdirectories. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultDirectoryAsync(Integer resultDirectoryId, String id, String sort, Integer limit, Integer compReport, String dir, final ApiCallback<ResultDirectories> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultDirectoryValidateBeforeCall(resultDirectoryId, id, sort, limit, compReport, dir, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultDirectories>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultHistogram
     * @param id  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultHistogramCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/histogram"
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultHistogramValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultHistogram(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultHistogramCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID.
     * @param id  (required)
     * @return ResultHistogram
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultHistogram getResultHistogram(String id) throws ApiException {
        ApiResponse<ResultHistogram> resp = getResultHistogramWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID.
     * @param id  (required)
     * @return ApiResponse&lt;ResultHistogram&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultHistogram> getResultHistogramWithHttpInfo(String id) throws ApiException {
        com.squareup.okhttp.Call call = getResultHistogramValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<ResultHistogram>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultHistogramAsync(String id, final ApiCallback<ResultHistogram> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultHistogramValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultHistogram>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultHistogramStat
     * @param resultHistogramStat This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultHistogramStatCall(String resultHistogramStat, String id, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/histogram/{ResultHistogramStat}"
            .replaceAll("\\{" + "ResultHistogramStat" + "\\}", apiClient.escapeString(resultHistogramStat.toString()))
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (directoryFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("directory_filter", directoryFilter));
        if (attributeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("attribute_filter", attributeFilter));
        if (nodePoolFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("node_pool_filter", nodePoolFilter));
        if (diskPoolFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("disk_pool_filter", diskPoolFilter));
        if (tierFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("tier_filter", tierFilter));
        if (compReport != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("comp_report", compReport));
        if (logSizeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("log_size_filter", logSizeFilter));
        if (physSizeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("phys_size_filter", physSizeFilter));
        if (pathExtFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path_ext_filter", pathExtFilter));
        if (ctimeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("ctime_filter", ctimeFilter));
        if (atimeFilter != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("atime_filter", atimeFilter));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultHistogramStatValidateBeforeCall(String resultHistogramStat, String id, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'resultHistogramStat' is set
        if (resultHistogramStat == null) {
            throw new ApiException("Missing the required parameter 'resultHistogramStat' when calling getResultHistogramStat(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultHistogramStat(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultHistogramStatCall(resultHistogramStat, id, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, pathExtFilter, ctimeFilter, atimeFilter, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID.
     * @param resultHistogramStat This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @return ResultHistogram
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultHistogram getResultHistogramStat(String resultHistogramStat, String id, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter) throws ApiException {
        ApiResponse<ResultHistogram> resp = getResultHistogramStatWithHttpInfo(resultHistogramStat, id, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, pathExtFilter, ctimeFilter, atimeFilter);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID.
     * @param resultHistogramStat This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @return ApiResponse&lt;ResultHistogram&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultHistogram> getResultHistogramStatWithHttpInfo(String resultHistogramStat, String id, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter) throws ApiException {
        com.squareup.okhttp.Call call = getResultHistogramStatValidateBeforeCall(resultHistogramStat, id, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, pathExtFilter, ctimeFilter, atimeFilter, null, null);
        Type localVarReturnType = new TypeToken<ResultHistogram>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID.
     * @param resultHistogramStat This resource retrieves a histogram of file counts for an individual FSA result set. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param directoryFilter Filter according to a specific directory, which includes all of its subdirectories. (optional)
     * @param attributeFilter Filter according to the name of a file user attribute. (optional)
     * @param nodePoolFilter Filter according to the name of a node pool, which is a set of disk pools that belong to nodes of the same equivalence class. (optional)
     * @param diskPoolFilter Filter according to the name of a disk pool, which is a set of drives that represent an independent failure domain. (optional)
     * @param tierFilter Filter according to the name of a storage tier, which is a user-created set of node pools. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param logSizeFilter Filter according to file logical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by logical size. The list of valid log_size filter values may be found by performing a histogram breakout by log_size and viewing the resulting key values. (optional)
     * @param physSizeFilter Filter according to file physical size, where the filter value specifies the lower bound in bytes to a set of files that have been grouped by physical size. The list of valid phys_size filter values may be found by performing a histogram breakout by phys_size and viewing the resulting key values. (optional)
     * @param pathExtFilter Filter according to the name of a single file extension. (optional)
     * @param ctimeFilter Filter according to file modified time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid ctime filter values may be found by performing a histogram breakout by ctime and viewing the resulting key values. (optional)
     * @param atimeFilter Filter according to file accessed time, where the filter value specifies a negative number of seconds representing a time before the begin time of the report. The list of valid atime filter values may be found by performing a histogram breakout by atime and viewing the resulting key values. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultHistogramStatAsync(String resultHistogramStat, String id, String directoryFilter, String attributeFilter, String nodePoolFilter, String diskPoolFilter, String tierFilter, Integer compReport, Integer logSizeFilter, Integer physSizeFilter, String pathExtFilter, Integer ctimeFilter, Integer atimeFilter, final ApiCallback<ResultHistogram> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultHistogramStatValidateBeforeCall(resultHistogramStat, id, directoryFilter, attributeFilter, nodePoolFilter, diskPoolFilter, tierFilter, compReport, logSizeFilter, physSizeFilter, pathExtFilter, ctimeFilter, atimeFilter, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultHistogram>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultTopDir
     * @param resultTopDirId This resource retrieves the top directories. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultTopDirCall(String resultTopDirId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/top-dirs/{ResultTopDirId}"
            .replaceAll("\\{" + "ResultTopDirId" + "\\}", apiClient.escapeString(resultTopDirId.toString()))
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        if (start != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("start", start));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (compReport != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("comp_report", compReport));
        if (dir != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("dir", dir));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultTopDirValidateBeforeCall(String resultTopDirId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'resultTopDirId' is set
        if (resultTopDirId == null) {
            throw new ApiException("Missing the required parameter 'resultTopDirId' when calling getResultTopDir(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultTopDir(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultTopDirCall(resultTopDirId, id, sort, start, limit, compReport, dir, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves the top directories. ID in the resource path is the result set ID.
     * @param resultTopDirId This resource retrieves the top directories. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ResultTopDirs
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultTopDirs getResultTopDir(String resultTopDirId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir) throws ApiException {
        ApiResponse<ResultTopDirs> resp = getResultTopDirWithHttpInfo(resultTopDirId, id, sort, start, limit, compReport, dir);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves the top directories. ID in the resource path is the result set ID.
     * @param resultTopDirId This resource retrieves the top directories. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ApiResponse&lt;ResultTopDirs&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultTopDirs> getResultTopDirWithHttpInfo(String resultTopDirId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir) throws ApiException {
        com.squareup.okhttp.Call call = getResultTopDirValidateBeforeCall(resultTopDirId, id, sort, start, limit, compReport, dir, null, null);
        Type localVarReturnType = new TypeToken<ResultTopDirs>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves the top directories. ID in the resource path is the result set ID.
     * @param resultTopDirId This resource retrieves the top directories. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultTopDirAsync(String resultTopDirId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir, final ApiCallback<ResultTopDirs> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultTopDirValidateBeforeCall(resultTopDirId, id, sort, start, limit, compReport, dir, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultTopDirs>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultTopDirs
     * @param id  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultTopDirsCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/top-dirs"
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultTopDirsValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultTopDirs(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultTopDirsCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves the top directories. ID in the resource path is the result set ID.
     * @param id  (required)
     * @return ResultTopDirs
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultTopDirs getResultTopDirs(String id) throws ApiException {
        ApiResponse<ResultTopDirs> resp = getResultTopDirsWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves the top directories. ID in the resource path is the result set ID.
     * @param id  (required)
     * @return ApiResponse&lt;ResultTopDirs&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultTopDirs> getResultTopDirsWithHttpInfo(String id) throws ApiException {
        com.squareup.okhttp.Call call = getResultTopDirsValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<ResultTopDirs>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves the top directories. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultTopDirsAsync(String id, final ApiCallback<ResultTopDirs> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultTopDirsValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultTopDirs>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultTopFile
     * @param resultTopFileId This resource retrieves the top files. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultTopFileCall(String resultTopFileId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/top-files/{ResultTopFileId}"
            .replaceAll("\\{" + "ResultTopFileId" + "\\}", apiClient.escapeString(resultTopFileId.toString()))
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("sort", sort));
        if (start != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("start", start));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (compReport != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("comp_report", compReport));
        if (dir != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("dir", dir));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultTopFileValidateBeforeCall(String resultTopFileId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'resultTopFileId' is set
        if (resultTopFileId == null) {
            throw new ApiException("Missing the required parameter 'resultTopFileId' when calling getResultTopFile(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultTopFile(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultTopFileCall(resultTopFileId, id, sort, start, limit, compReport, dir, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves the top files. ID in the resource path is the result set ID.
     * @param resultTopFileId This resource retrieves the top files. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ResultTopFiles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultTopFiles getResultTopFile(String resultTopFileId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir) throws ApiException {
        ApiResponse<ResultTopFiles> resp = getResultTopFileWithHttpInfo(resultTopFileId, id, sort, start, limit, compReport, dir);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves the top files. ID in the resource path is the result set ID.
     * @param resultTopFileId This resource retrieves the top files. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @return ApiResponse&lt;ResultTopFiles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultTopFiles> getResultTopFileWithHttpInfo(String resultTopFileId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir) throws ApiException {
        com.squareup.okhttp.Call call = getResultTopFileValidateBeforeCall(resultTopFileId, id, sort, start, limit, compReport, dir, null, null);
        Type localVarReturnType = new TypeToken<ResultTopFiles>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves the top files. ID in the resource path is the result set ID.
     * @param resultTopFileId This resource retrieves the top files. ID in the resource path is the result set ID. (required)
     * @param id  (required)
     * @param sort The field that will be used for sorting. (optional)
     * @param start Starting index for results. Default value of 0. (optional)
     * @param limit Number of results from start index. Default value of 1000. (optional)
     * @param compReport Result set identifier for comparison of database results. (optional)
     * @param dir The direction of the sort. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultTopFileAsync(String resultTopFileId, String id, String sort, Integer start, Integer limit, Integer compReport, String dir, final ApiCallback<ResultTopFiles> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultTopFileValidateBeforeCall(resultTopFileId, id, sort, start, limit, compReport, dir, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultTopFiles>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for getResultTopFiles
     * @param id  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call getResultTopFilesCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/platform/3/fsa/results/{Id}/top-files"
            .replaceAll("\\{" + "Id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getResultTopFilesValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getResultTopFiles(Async)");
        }
        

        com.squareup.okhttp.Call call = getResultTopFilesCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * This resource retrieves the top files. ID in the resource path is the result set ID.
     * @param id  (required)
     * @return ResultTopFiles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ResultTopFiles getResultTopFiles(String id) throws ApiException {
        ApiResponse<ResultTopFiles> resp = getResultTopFilesWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * 
     * This resource retrieves the top files. ID in the resource path is the result set ID.
     * @param id  (required)
     * @return ApiResponse&lt;ResultTopFiles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ResultTopFiles> getResultTopFilesWithHttpInfo(String id) throws ApiException {
        com.squareup.okhttp.Call call = getResultTopFilesValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<ResultTopFiles>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * This resource retrieves the top files. ID in the resource path is the result set ID.
     * @param id  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getResultTopFilesAsync(String id, final ApiCallback<ResultTopFiles> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getResultTopFilesValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ResultTopFiles>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
