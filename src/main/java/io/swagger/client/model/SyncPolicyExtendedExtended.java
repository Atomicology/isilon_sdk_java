/*
 * Isilon SDK
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.SyncJobPolicyFileMatchingPattern;
import io.swagger.client.model.SyncPolicySourceNetwork;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * SyncPolicyExtendedExtended
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-04-18T15:45:33.897-07:00")
public class SyncPolicyExtendedExtended {
  @SerializedName("accelerated_failback")
  private Boolean acceleratedFailback = null;

  /**
   * If &#39;copy&#39;, source files will be copied to the target cluster.  If &#39;sync&#39;, the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.
   */
  @JsonAdapter(ActionEnum.Adapter.class)
  public enum ActionEnum {
    COPY("copy"),
    
    SYNC("sync");

    private String value;

    ActionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ActionEnum fromValue(String text) {
      for (ActionEnum b : ActionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ActionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ActionEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("action")
  private ActionEnum action = null;

  @SerializedName("burst_mode")
  private Boolean burstMode = null;

  @SerializedName("changelist")
  private Boolean changelist = null;

  @SerializedName("check_integrity")
  private Boolean checkIntegrity = null;

  /**
   * If set to deny, replicates all CloudPools smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, the job will fail. If set to force, replicates all smartlinks to the target cluster as regular files. If set to allow, SyncIQ will attempt to replicate smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, SyncIQ will replicate the smartlinks as regular files.
   */
  @JsonAdapter(CloudDeepCopyEnum.Adapter.class)
  public enum CloudDeepCopyEnum {
    DENY("deny"),
    
    ALLOW("allow"),
    
    FORCE("force");

    private String value;

    CloudDeepCopyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CloudDeepCopyEnum fromValue(String text) {
      for (CloudDeepCopyEnum b : CloudDeepCopyEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<CloudDeepCopyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CloudDeepCopyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CloudDeepCopyEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return CloudDeepCopyEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("cloud_deep_copy")
  private CloudDeepCopyEnum cloudDeepCopy = null;

  @SerializedName("conflicted")
  private Boolean conflicted = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("disable_file_split")
  private Boolean disableFileSplit = null;

  @SerializedName("disable_fofb")
  private Boolean disableFofb = null;

  @SerializedName("disable_stf")
  private Boolean disableStf = null;

  @SerializedName("enabled")
  private Boolean enabled = null;

  @SerializedName("expected_dataloss")
  private Boolean expectedDataloss = null;

  @SerializedName("file_matching_pattern")
  private SyncJobPolicyFileMatchingPattern fileMatchingPattern = null;

  @SerializedName("force_interface")
  private Boolean forceInterface = null;

  @SerializedName("has_sync_state")
  private Boolean hasSyncState = null;

  @SerializedName("id")
  private String id = null;

  @SerializedName("job_delay")
  private Integer jobDelay = null;

  @SerializedName("last_job_state")
  private String lastJobState = null;

  @SerializedName("last_started")
  private Integer lastStarted = null;

  @SerializedName("last_success")
  private Integer lastSuccess = null;

  /**
   * Severity an event must reach before it is logged.
   */
  @JsonAdapter(LogLevelEnum.Adapter.class)
  public enum LogLevelEnum {
    FATAL("fatal"),
    
    ERROR("error"),
    
    NOTICE("notice"),
    
    INFO("info"),
    
    COPY("copy"),
    
    DEBUG("debug"),
    
    TRACE("trace");

    private String value;

    LogLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LogLevelEnum fromValue(String text) {
      for (LogLevelEnum b : LogLevelEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<LogLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return LogLevelEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("log_level")
  private LogLevelEnum logLevel = null;

  @SerializedName("log_removed_files")
  private Boolean logRemovedFiles = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("next_run")
  private Integer nextRun = null;

  @SerializedName("password_set")
  private Boolean passwordSet = null;

  @SerializedName("priority")
  private Integer priority = null;

  @SerializedName("report_max_age")
  private Integer reportMaxAge = null;

  @SerializedName("report_max_count")
  private Integer reportMaxCount = null;

  @SerializedName("restrict_target_network")
  private Boolean restrictTargetNetwork = null;

  @SerializedName("rpo_alert")
  private Integer rpoAlert = null;

  @SerializedName("schedule")
  private String schedule = null;

  @SerializedName("skip_lookup")
  private Boolean skipLookup = null;

  @SerializedName("skip_when_source_unmodified")
  private Boolean skipWhenSourceUnmodified = null;

  @SerializedName("snapshot_sync_existing")
  private Boolean snapshotSyncExisting = null;

  @SerializedName("snapshot_sync_pattern")
  private String snapshotSyncPattern = null;

  @SerializedName("source_exclude_directories")
  private List<String> sourceExcludeDirectories = null;

  @SerializedName("source_include_directories")
  private List<String> sourceIncludeDirectories = null;

  @SerializedName("source_network")
  private SyncPolicySourceNetwork sourceNetwork = null;

  @SerializedName("source_root_path")
  private String sourceRootPath = null;

  @SerializedName("source_snapshot_archive")
  private Boolean sourceSnapshotArchive = null;

  @SerializedName("source_snapshot_expiration")
  private Integer sourceSnapshotExpiration = null;

  @SerializedName("source_snapshot_pattern")
  private String sourceSnapshotPattern = null;

  @SerializedName("target_compare_initial_sync")
  private Boolean targetCompareInitialSync = null;

  @SerializedName("target_detect_modifications")
  private Boolean targetDetectModifications = null;

  @SerializedName("target_host")
  private String targetHost = null;

  @SerializedName("target_path")
  private String targetPath = null;

  @SerializedName("target_snapshot_alias")
  private String targetSnapshotAlias = null;

  @SerializedName("target_snapshot_archive")
  private Boolean targetSnapshotArchive = null;

  @SerializedName("target_snapshot_expiration")
  private Integer targetSnapshotExpiration = null;

  @SerializedName("target_snapshot_pattern")
  private String targetSnapshotPattern = null;

  @SerializedName("workers_per_node")
  private Integer workersPerNode = null;

  public SyncPolicyExtendedExtended acceleratedFailback(Boolean acceleratedFailback) {
    this.acceleratedFailback = acceleratedFailback;
    return this;
  }

   /**
   * If set to true, SyncIQ will perform failback configuration tasks during the next job run, rather than waiting to perform those tasks during the failback process. Performing these tasks ahead of time will increase the speed of failback operations.
   * @return acceleratedFailback
  **/
  @ApiModelProperty(value = "If set to true, SyncIQ will perform failback configuration tasks during the next job run, rather than waiting to perform those tasks during the failback process. Performing these tasks ahead of time will increase the speed of failback operations.")
  public Boolean isAcceleratedFailback() {
    return acceleratedFailback;
  }

  public void setAcceleratedFailback(Boolean acceleratedFailback) {
    this.acceleratedFailback = acceleratedFailback;
  }

  public SyncPolicyExtendedExtended action(ActionEnum action) {
    this.action = action;
    return this;
  }

   /**
   * If &#39;copy&#39;, source files will be copied to the target cluster.  If &#39;sync&#39;, the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.
   * @return action
  **/
  @ApiModelProperty(value = "If 'copy', source files will be copied to the target cluster.  If 'sync', the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.")
  public ActionEnum getAction() {
    return action;
  }

  public void setAction(ActionEnum action) {
    this.action = action;
  }

  public SyncPolicyExtendedExtended burstMode(Boolean burstMode) {
    this.burstMode = burstMode;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  Enable/disable UDP-based data transfer.
   * @return burstMode
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  Enable/disable UDP-based data transfer.")
  public Boolean isBurstMode() {
    return burstMode;
  }

  public void setBurstMode(Boolean burstMode) {
    this.burstMode = burstMode;
  }

  public SyncPolicyExtendedExtended changelist(Boolean changelist) {
    this.changelist = changelist;
    return this;
  }

   /**
   * If true, retain previous source snapshot and incremental repstate, both of which are required for changelist creation.
   * @return changelist
  **/
  @ApiModelProperty(value = "If true, retain previous source snapshot and incremental repstate, both of which are required for changelist creation.")
  public Boolean isChangelist() {
    return changelist;
  }

  public void setChangelist(Boolean changelist) {
    this.changelist = changelist;
  }

  public SyncPolicyExtendedExtended checkIntegrity(Boolean checkIntegrity) {
    this.checkIntegrity = checkIntegrity;
    return this;
  }

   /**
   * If true, the sync target performs cyclic redundancy checks (CRC) on the data as it is received.
   * @return checkIntegrity
  **/
  @ApiModelProperty(value = "If true, the sync target performs cyclic redundancy checks (CRC) on the data as it is received.")
  public Boolean isCheckIntegrity() {
    return checkIntegrity;
  }

  public void setCheckIntegrity(Boolean checkIntegrity) {
    this.checkIntegrity = checkIntegrity;
  }

  public SyncPolicyExtendedExtended cloudDeepCopy(CloudDeepCopyEnum cloudDeepCopy) {
    this.cloudDeepCopy = cloudDeepCopy;
    return this;
  }

   /**
   * If set to deny, replicates all CloudPools smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, the job will fail. If set to force, replicates all smartlinks to the target cluster as regular files. If set to allow, SyncIQ will attempt to replicate smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, SyncIQ will replicate the smartlinks as regular files.
   * @return cloudDeepCopy
  **/
  @ApiModelProperty(value = "If set to deny, replicates all CloudPools smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, the job will fail. If set to force, replicates all smartlinks to the target cluster as regular files. If set to allow, SyncIQ will attempt to replicate smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, SyncIQ will replicate the smartlinks as regular files.")
  public CloudDeepCopyEnum getCloudDeepCopy() {
    return cloudDeepCopy;
  }

  public void setCloudDeepCopy(CloudDeepCopyEnum cloudDeepCopy) {
    this.cloudDeepCopy = cloudDeepCopy;
  }

  public SyncPolicyExtendedExtended conflicted(Boolean conflicted) {
    this.conflicted = conflicted;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  If true, the most recent run of this policy encountered an error and this policy will not start any more scheduled jobs until this field is manually set back to &#39;false&#39;.
   * @return conflicted
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  If true, the most recent run of this policy encountered an error and this policy will not start any more scheduled jobs until this field is manually set back to 'false'.")
  public Boolean isConflicted() {
    return conflicted;
  }

  public void setConflicted(Boolean conflicted) {
    this.conflicted = conflicted;
  }

  public SyncPolicyExtendedExtended description(String description) {
    this.description = description;
    return this;
  }

   /**
   * User-assigned description of this sync policy.
   * @return description
  **/
  @ApiModelProperty(value = "User-assigned description of this sync policy.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public SyncPolicyExtendedExtended disableFileSplit(Boolean disableFileSplit) {
    this.disableFileSplit = disableFileSplit;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  If true, the 7.2+ file splitting capability will be disabled.
   * @return disableFileSplit
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  If true, the 7.2+ file splitting capability will be disabled.")
  public Boolean isDisableFileSplit() {
    return disableFileSplit;
  }

  public void setDisableFileSplit(Boolean disableFileSplit) {
    this.disableFileSplit = disableFileSplit;
  }

  public SyncPolicyExtendedExtended disableFofb(Boolean disableFofb) {
    this.disableFofb = disableFofb;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  Enable/disable sync failover/failback.
   * @return disableFofb
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  Enable/disable sync failover/failback.")
  public Boolean isDisableFofb() {
    return disableFofb;
  }

  public void setDisableFofb(Boolean disableFofb) {
    this.disableFofb = disableFofb;
  }

  public SyncPolicyExtendedExtended disableStf(Boolean disableStf) {
    this.disableStf = disableStf;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  Enable/disable the 6.5+ STF based data transfer and uses only treewalk.
   * @return disableStf
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  Enable/disable the 6.5+ STF based data transfer and uses only treewalk.")
  public Boolean isDisableStf() {
    return disableStf;
  }

  public void setDisableStf(Boolean disableStf) {
    this.disableStf = disableStf;
  }

  public SyncPolicyExtendedExtended enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

   /**
   * If true, jobs will be automatically run based on this policy, according to its schedule.
   * @return enabled
  **/
  @ApiModelProperty(required = true, value = "If true, jobs will be automatically run based on this policy, according to its schedule.")
  public Boolean isEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }

  public SyncPolicyExtendedExtended expectedDataloss(Boolean expectedDataloss) {
    this.expectedDataloss = expectedDataloss;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  Continue sending files even with the corrupted filesystem.
   * @return expectedDataloss
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  Continue sending files even with the corrupted filesystem.")
  public Boolean isExpectedDataloss() {
    return expectedDataloss;
  }

  public void setExpectedDataloss(Boolean expectedDataloss) {
    this.expectedDataloss = expectedDataloss;
  }

  public SyncPolicyExtendedExtended fileMatchingPattern(SyncJobPolicyFileMatchingPattern fileMatchingPattern) {
    this.fileMatchingPattern = fileMatchingPattern;
    return this;
  }

   /**
   * A file matching pattern, organized as an OR&#39;ed set of AND&#39;ed file criteria, for example ((a AND b) OR (x AND y)) used to define a set of files with specific properties.  Policies of type &#39;sync&#39; cannot use &#39;path&#39; or time criteria in their matching patterns, but policies of type &#39;copy&#39; can use all listed criteria.
   * @return fileMatchingPattern
  **/
  @ApiModelProperty(value = "A file matching pattern, organized as an OR'ed set of AND'ed file criteria, for example ((a AND b) OR (x AND y)) used to define a set of files with specific properties.  Policies of type 'sync' cannot use 'path' or time criteria in their matching patterns, but policies of type 'copy' can use all listed criteria.")
  public SyncJobPolicyFileMatchingPattern getFileMatchingPattern() {
    return fileMatchingPattern;
  }

  public void setFileMatchingPattern(SyncJobPolicyFileMatchingPattern fileMatchingPattern) {
    this.fileMatchingPattern = fileMatchingPattern;
  }

  public SyncPolicyExtendedExtended forceInterface(Boolean forceInterface) {
    this.forceInterface = forceInterface;
    return this;
  }

   /**
   * NOTE: This field should not be changed without the help of Isilon support.  Determines whether data is sent only through the subnet and pool specified in the \&quot;source_network\&quot; field. This option can be useful if there are multiple interfaces for the given source subnet.  If you enable this option, the net.inet.ip.choose_ifa_by_ipsrc sysctl should be set.
   * @return forceInterface
  **/
  @ApiModelProperty(value = "NOTE: This field should not be changed without the help of Isilon support.  Determines whether data is sent only through the subnet and pool specified in the \"source_network\" field. This option can be useful if there are multiple interfaces for the given source subnet.  If you enable this option, the net.inet.ip.choose_ifa_by_ipsrc sysctl should be set.")
  public Boolean isForceInterface() {
    return forceInterface;
  }

  public void setForceInterface(Boolean forceInterface) {
    this.forceInterface = forceInterface;
  }

  public SyncPolicyExtendedExtended hasSyncState(Boolean hasSyncState) {
    this.hasSyncState = hasSyncState;
    return this;
  }

   /**
   * This field is false if the policy is in its initial sync state and true otherwise.  Setting this field to false will reset the policy&#39;s sync state.
   * @return hasSyncState
  **/
  @ApiModelProperty(value = "This field is false if the policy is in its initial sync state and true otherwise.  Setting this field to false will reset the policy's sync state.")
  public Boolean isHasSyncState() {
    return hasSyncState;
  }

  public void setHasSyncState(Boolean hasSyncState) {
    this.hasSyncState = hasSyncState;
  }

  public SyncPolicyExtendedExtended id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The system ID given to this sync policy.
   * @return id
  **/
  @ApiModelProperty(required = true, value = "The system ID given to this sync policy.")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public SyncPolicyExtendedExtended jobDelay(Integer jobDelay) {
    this.jobDelay = jobDelay;
    return this;
  }

   /**
   * If --schedule is set to When-Source-Modified, the duration to wait after a modification is made before starting a job (default is 0 seconds).
   * minimum: 0
   * @return jobDelay
  **/
  @ApiModelProperty(value = "If --schedule is set to When-Source-Modified, the duration to wait after a modification is made before starting a job (default is 0 seconds).")
  public Integer getJobDelay() {
    return jobDelay;
  }

  public void setJobDelay(Integer jobDelay) {
    this.jobDelay = jobDelay;
  }

  public SyncPolicyExtendedExtended lastJobState(String lastJobState) {
    this.lastJobState = lastJobState;
    return this;
  }

   /**
   * This is the state of the most recent job for this policy.
   * @return lastJobState
  **/
  @ApiModelProperty(value = "This is the state of the most recent job for this policy.")
  public String getLastJobState() {
    return lastJobState;
  }

  public void setLastJobState(String lastJobState) {
    this.lastJobState = lastJobState;
  }

  public SyncPolicyExtendedExtended lastStarted(Integer lastStarted) {
    this.lastStarted = lastStarted;
    return this;
  }

   /**
   * The most recent time a job was started for this policy.  Value is null if the policy has never been run.
   * minimum: 0
   * @return lastStarted
  **/
  @ApiModelProperty(value = "The most recent time a job was started for this policy.  Value is null if the policy has never been run.")
  public Integer getLastStarted() {
    return lastStarted;
  }

  public void setLastStarted(Integer lastStarted) {
    this.lastStarted = lastStarted;
  }

  public SyncPolicyExtendedExtended lastSuccess(Integer lastSuccess) {
    this.lastSuccess = lastSuccess;
    return this;
  }

   /**
   * Timestamp of last known successfully completed synchronization.  Value is null if the policy has never completed successfully.
   * minimum: 0
   * @return lastSuccess
  **/
  @ApiModelProperty(value = "Timestamp of last known successfully completed synchronization.  Value is null if the policy has never completed successfully.")
  public Integer getLastSuccess() {
    return lastSuccess;
  }

  public void setLastSuccess(Integer lastSuccess) {
    this.lastSuccess = lastSuccess;
  }

  public SyncPolicyExtendedExtended logLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
    return this;
  }

   /**
   * Severity an event must reach before it is logged.
   * @return logLevel
  **/
  @ApiModelProperty(value = "Severity an event must reach before it is logged.")
  public LogLevelEnum getLogLevel() {
    return logLevel;
  }

  public void setLogLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
  }

  public SyncPolicyExtendedExtended logRemovedFiles(Boolean logRemovedFiles) {
    this.logRemovedFiles = logRemovedFiles;
    return this;
  }

   /**
   * If true, the system will log any files or directories that are deleted due to a sync.
   * @return logRemovedFiles
  **/
  @ApiModelProperty(value = "If true, the system will log any files or directories that are deleted due to a sync.")
  public Boolean isLogRemovedFiles() {
    return logRemovedFiles;
  }

  public void setLogRemovedFiles(Boolean logRemovedFiles) {
    this.logRemovedFiles = logRemovedFiles;
  }

  public SyncPolicyExtendedExtended name(String name) {
    this.name = name;
    return this;
  }

   /**
   * User-assigned name of this sync policy.
   * @return name
  **/
  @ApiModelProperty(required = true, value = "User-assigned name of this sync policy.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public SyncPolicyExtendedExtended nextRun(Integer nextRun) {
    this.nextRun = nextRun;
    return this;
  }

   /**
   * This is the next time a job is scheduled to run for this policy in Unix epoch seconds.  This field is null if the job is not scheduled.
   * @return nextRun
  **/
  @ApiModelProperty(value = "This is the next time a job is scheduled to run for this policy in Unix epoch seconds.  This field is null if the job is not scheduled.")
  public Integer getNextRun() {
    return nextRun;
  }

  public void setNextRun(Integer nextRun) {
    this.nextRun = nextRun;
  }

  public SyncPolicyExtendedExtended passwordSet(Boolean passwordSet) {
    this.passwordSet = passwordSet;
    return this;
  }

   /**
   * Indicates if a password is set for accessing the target cluster. Password value is not shown with GET.
   * @return passwordSet
  **/
  @ApiModelProperty(value = "Indicates if a password is set for accessing the target cluster. Password value is not shown with GET.")
  public Boolean isPasswordSet() {
    return passwordSet;
  }

  public void setPasswordSet(Boolean passwordSet) {
    this.passwordSet = passwordSet;
  }

  public SyncPolicyExtendedExtended priority(Integer priority) {
    this.priority = priority;
    return this;
  }

   /**
   * Determines the priority level of a policy. Policies with higher priority will have precedence to run over lower priority policies. Valid range is [0, 1]. Default is 0.
   * @return priority
  **/
  @ApiModelProperty(value = "Determines the priority level of a policy. Policies with higher priority will have precedence to run over lower priority policies. Valid range is [0, 1]. Default is 0.")
  public Integer getPriority() {
    return priority;
  }

  public void setPriority(Integer priority) {
    this.priority = priority;
  }

  public SyncPolicyExtendedExtended reportMaxAge(Integer reportMaxAge) {
    this.reportMaxAge = reportMaxAge;
    return this;
  }

   /**
   * Length of time (in seconds) a policy report will be stored.
   * minimum: 0
   * @return reportMaxAge
  **/
  @ApiModelProperty(value = "Length of time (in seconds) a policy report will be stored.")
  public Integer getReportMaxAge() {
    return reportMaxAge;
  }

  public void setReportMaxAge(Integer reportMaxAge) {
    this.reportMaxAge = reportMaxAge;
  }

  public SyncPolicyExtendedExtended reportMaxCount(Integer reportMaxCount) {
    this.reportMaxCount = reportMaxCount;
    return this;
  }

   /**
   * Maximum number of policy reports that will be stored on the system.
   * minimum: 1
   * maximum: 2000
   * @return reportMaxCount
  **/
  @ApiModelProperty(value = "Maximum number of policy reports that will be stored on the system.")
  public Integer getReportMaxCount() {
    return reportMaxCount;
  }

  public void setReportMaxCount(Integer reportMaxCount) {
    this.reportMaxCount = reportMaxCount;
  }

  public SyncPolicyExtendedExtended restrictTargetNetwork(Boolean restrictTargetNetwork) {
    this.restrictTargetNetwork = restrictTargetNetwork;
    return this;
  }

   /**
   * If you specify true, and you specify a SmartConnect zone in the \&quot;target_host\&quot; field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.
   * @return restrictTargetNetwork
  **/
  @ApiModelProperty(value = "If you specify true, and you specify a SmartConnect zone in the \"target_host\" field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.")
  public Boolean isRestrictTargetNetwork() {
    return restrictTargetNetwork;
  }

  public void setRestrictTargetNetwork(Boolean restrictTargetNetwork) {
    this.restrictTargetNetwork = restrictTargetNetwork;
  }

  public SyncPolicyExtendedExtended rpoAlert(Integer rpoAlert) {
    this.rpoAlert = rpoAlert;
    return this;
  }

   /**
   * If --schedule is set to a time/date, an alert is created if the specified RPO for this policy is exceeded. The default value is 0, which will not generate RPO alerts.
   * minimum: 0
   * @return rpoAlert
  **/
  @ApiModelProperty(value = "If --schedule is set to a time/date, an alert is created if the specified RPO for this policy is exceeded. The default value is 0, which will not generate RPO alerts.")
  public Integer getRpoAlert() {
    return rpoAlert;
  }

  public void setRpoAlert(Integer rpoAlert) {
    this.rpoAlert = rpoAlert;
  }

  public SyncPolicyExtendedExtended schedule(String schedule) {
    this.schedule = schedule;
    return this;
  }

   /**
   * The schedule on which new jobs will be run for this policy.
   * @return schedule
  **/
  @ApiModelProperty(required = true, value = "The schedule on which new jobs will be run for this policy.")
  public String getSchedule() {
    return schedule;
  }

  public void setSchedule(String schedule) {
    this.schedule = schedule;
  }

  public SyncPolicyExtendedExtended skipLookup(Boolean skipLookup) {
    this.skipLookup = skipLookup;
    return this;
  }

   /**
   * Skip DNS lookup of target IPs.
   * @return skipLookup
  **/
  @ApiModelProperty(value = "Skip DNS lookup of target IPs.")
  public Boolean isSkipLookup() {
    return skipLookup;
  }

  public void setSkipLookup(Boolean skipLookup) {
    this.skipLookup = skipLookup;
  }

  public SyncPolicyExtendedExtended skipWhenSourceUnmodified(Boolean skipWhenSourceUnmodified) {
    this.skipWhenSourceUnmodified = skipWhenSourceUnmodified;
    return this;
  }

   /**
   * If true and --schedule is set to a time/date, the policy will not run if no changes have been made to the contents of the source directory since the last job successfully completed.
   * @return skipWhenSourceUnmodified
  **/
  @ApiModelProperty(value = "If true and --schedule is set to a time/date, the policy will not run if no changes have been made to the contents of the source directory since the last job successfully completed.")
  public Boolean isSkipWhenSourceUnmodified() {
    return skipWhenSourceUnmodified;
  }

  public void setSkipWhenSourceUnmodified(Boolean skipWhenSourceUnmodified) {
    this.skipWhenSourceUnmodified = skipWhenSourceUnmodified;
  }

  public SyncPolicyExtendedExtended snapshotSyncExisting(Boolean snapshotSyncExisting) {
    this.snapshotSyncExisting = snapshotSyncExisting;
    return this;
  }

   /**
   * If true, snapshot-triggered syncs will include snapshots taken before policy creation time (requires --schedule when-snapshot-taken).
   * @return snapshotSyncExisting
  **/
  @ApiModelProperty(value = "If true, snapshot-triggered syncs will include snapshots taken before policy creation time (requires --schedule when-snapshot-taken).")
  public Boolean isSnapshotSyncExisting() {
    return snapshotSyncExisting;
  }

  public void setSnapshotSyncExisting(Boolean snapshotSyncExisting) {
    this.snapshotSyncExisting = snapshotSyncExisting;
  }

  public SyncPolicyExtendedExtended snapshotSyncPattern(String snapshotSyncPattern) {
    this.snapshotSyncPattern = snapshotSyncPattern;
    return this;
  }

   /**
   * The naming pattern that a snapshot must match to trigger a sync when the schedule is when-snapshot-taken (default is \&quot;*\&quot;).
   * @return snapshotSyncPattern
  **/
  @ApiModelProperty(value = "The naming pattern that a snapshot must match to trigger a sync when the schedule is when-snapshot-taken (default is \"*\").")
  public String getSnapshotSyncPattern() {
    return snapshotSyncPattern;
  }

  public void setSnapshotSyncPattern(String snapshotSyncPattern) {
    this.snapshotSyncPattern = snapshotSyncPattern;
  }

  public SyncPolicyExtendedExtended sourceExcludeDirectories(List<String> sourceExcludeDirectories) {
    this.sourceExcludeDirectories = sourceExcludeDirectories;
    return this;
  }

  public SyncPolicyExtendedExtended addSourceExcludeDirectoriesItem(String sourceExcludeDirectoriesItem) {
    if (this.sourceExcludeDirectories == null) {
      this.sourceExcludeDirectories = new ArrayList<String>();
    }
    this.sourceExcludeDirectories.add(sourceExcludeDirectoriesItem);
    return this;
  }

   /**
   * Directories that will be excluded from the sync.  Modifying this field will result in a full synchronization of all data.
   * @return sourceExcludeDirectories
  **/
  @ApiModelProperty(value = "Directories that will be excluded from the sync.  Modifying this field will result in a full synchronization of all data.")
  public List<String> getSourceExcludeDirectories() {
    return sourceExcludeDirectories;
  }

  public void setSourceExcludeDirectories(List<String> sourceExcludeDirectories) {
    this.sourceExcludeDirectories = sourceExcludeDirectories;
  }

  public SyncPolicyExtendedExtended sourceIncludeDirectories(List<String> sourceIncludeDirectories) {
    this.sourceIncludeDirectories = sourceIncludeDirectories;
    return this;
  }

  public SyncPolicyExtendedExtended addSourceIncludeDirectoriesItem(String sourceIncludeDirectoriesItem) {
    if (this.sourceIncludeDirectories == null) {
      this.sourceIncludeDirectories = new ArrayList<String>();
    }
    this.sourceIncludeDirectories.add(sourceIncludeDirectoriesItem);
    return this;
  }

   /**
   * Directories that will be included in the sync.  Modifying this field will result in a full synchronization of all data.
   * @return sourceIncludeDirectories
  **/
  @ApiModelProperty(value = "Directories that will be included in the sync.  Modifying this field will result in a full synchronization of all data.")
  public List<String> getSourceIncludeDirectories() {
    return sourceIncludeDirectories;
  }

  public void setSourceIncludeDirectories(List<String> sourceIncludeDirectories) {
    this.sourceIncludeDirectories = sourceIncludeDirectories;
  }

  public SyncPolicyExtendedExtended sourceNetwork(SyncPolicySourceNetwork sourceNetwork) {
    this.sourceNetwork = sourceNetwork;
    return this;
  }

   /**
   * Restricts replication policies on the local cluster to running on the specified subnet and pool.
   * @return sourceNetwork
  **/
  @ApiModelProperty(value = "Restricts replication policies on the local cluster to running on the specified subnet and pool.")
  public SyncPolicySourceNetwork getSourceNetwork() {
    return sourceNetwork;
  }

  public void setSourceNetwork(SyncPolicySourceNetwork sourceNetwork) {
    this.sourceNetwork = sourceNetwork;
  }

  public SyncPolicyExtendedExtended sourceRootPath(String sourceRootPath) {
    this.sourceRootPath = sourceRootPath;
    return this;
  }

   /**
   * The root directory on the source cluster the files will be synced from.  Modifying this field will result in a full synchronization of all data.
   * @return sourceRootPath
  **/
  @ApiModelProperty(required = true, value = "The root directory on the source cluster the files will be synced from.  Modifying this field will result in a full synchronization of all data.")
  public String getSourceRootPath() {
    return sourceRootPath;
  }

  public void setSourceRootPath(String sourceRootPath) {
    this.sourceRootPath = sourceRootPath;
  }

  public SyncPolicyExtendedExtended sourceSnapshotArchive(Boolean sourceSnapshotArchive) {
    this.sourceSnapshotArchive = sourceSnapshotArchive;
    return this;
  }

   /**
   * If true, archival snapshots of the source data will be taken on the source cluster before a sync.
   * @return sourceSnapshotArchive
  **/
  @ApiModelProperty(value = "If true, archival snapshots of the source data will be taken on the source cluster before a sync.")
  public Boolean isSourceSnapshotArchive() {
    return sourceSnapshotArchive;
  }

  public void setSourceSnapshotArchive(Boolean sourceSnapshotArchive) {
    this.sourceSnapshotArchive = sourceSnapshotArchive;
  }

  public SyncPolicyExtendedExtended sourceSnapshotExpiration(Integer sourceSnapshotExpiration) {
    this.sourceSnapshotExpiration = sourceSnapshotExpiration;
    return this;
  }

   /**
   * The length of time in seconds to keep snapshots on the source cluster.
   * minimum: 0
   * @return sourceSnapshotExpiration
  **/
  @ApiModelProperty(value = "The length of time in seconds to keep snapshots on the source cluster.")
  public Integer getSourceSnapshotExpiration() {
    return sourceSnapshotExpiration;
  }

  public void setSourceSnapshotExpiration(Integer sourceSnapshotExpiration) {
    this.sourceSnapshotExpiration = sourceSnapshotExpiration;
  }

  public SyncPolicyExtendedExtended sourceSnapshotPattern(String sourceSnapshotPattern) {
    this.sourceSnapshotPattern = sourceSnapshotPattern;
    return this;
  }

   /**
   * The name pattern for snapshots taken on the source cluster before a sync.
   * @return sourceSnapshotPattern
  **/
  @ApiModelProperty(value = "The name pattern for snapshots taken on the source cluster before a sync.")
  public String getSourceSnapshotPattern() {
    return sourceSnapshotPattern;
  }

  public void setSourceSnapshotPattern(String sourceSnapshotPattern) {
    this.sourceSnapshotPattern = sourceSnapshotPattern;
  }

  public SyncPolicyExtendedExtended targetCompareInitialSync(Boolean targetCompareInitialSync) {
    this.targetCompareInitialSync = targetCompareInitialSync;
    return this;
  }

   /**
   * If true, the target creates diffs against the original sync.
   * @return targetCompareInitialSync
  **/
  @ApiModelProperty(value = "If true, the target creates diffs against the original sync.")
  public Boolean isTargetCompareInitialSync() {
    return targetCompareInitialSync;
  }

  public void setTargetCompareInitialSync(Boolean targetCompareInitialSync) {
    this.targetCompareInitialSync = targetCompareInitialSync;
  }

  public SyncPolicyExtendedExtended targetDetectModifications(Boolean targetDetectModifications) {
    this.targetDetectModifications = targetDetectModifications;
    return this;
  }

   /**
   * If true, target cluster will detect if files have been changed on the target by legacy tree walk syncs.
   * @return targetDetectModifications
  **/
  @ApiModelProperty(value = "If true, target cluster will detect if files have been changed on the target by legacy tree walk syncs.")
  public Boolean isTargetDetectModifications() {
    return targetDetectModifications;
  }

  public void setTargetDetectModifications(Boolean targetDetectModifications) {
    this.targetDetectModifications = targetDetectModifications;
  }

  public SyncPolicyExtendedExtended targetHost(String targetHost) {
    this.targetHost = targetHost;
    return this;
  }

   /**
   * Hostname or IP address of sync target cluster.  Modifying the target cluster host can result in the policy being unrunnable if the new target does not match the current target association.
   * @return targetHost
  **/
  @ApiModelProperty(required = true, value = "Hostname or IP address of sync target cluster.  Modifying the target cluster host can result in the policy being unrunnable if the new target does not match the current target association.")
  public String getTargetHost() {
    return targetHost;
  }

  public void setTargetHost(String targetHost) {
    this.targetHost = targetHost;
  }

  public SyncPolicyExtendedExtended targetPath(String targetPath) {
    this.targetPath = targetPath;
    return this;
  }

   /**
   * Absolute filesystem path on the target cluster for the sync destination.
   * @return targetPath
  **/
  @ApiModelProperty(required = true, value = "Absolute filesystem path on the target cluster for the sync destination.")
  public String getTargetPath() {
    return targetPath;
  }

  public void setTargetPath(String targetPath) {
    this.targetPath = targetPath;
  }

  public SyncPolicyExtendedExtended targetSnapshotAlias(String targetSnapshotAlias) {
    this.targetSnapshotAlias = targetSnapshotAlias;
    return this;
  }

   /**
   * The alias of the snapshot taken on the target cluster after the sync completes. A value of @DEFAULT will reset this field to the default creation value.
   * @return targetSnapshotAlias
  **/
  @ApiModelProperty(value = "The alias of the snapshot taken on the target cluster after the sync completes. A value of @DEFAULT will reset this field to the default creation value.")
  public String getTargetSnapshotAlias() {
    return targetSnapshotAlias;
  }

  public void setTargetSnapshotAlias(String targetSnapshotAlias) {
    this.targetSnapshotAlias = targetSnapshotAlias;
  }

  public SyncPolicyExtendedExtended targetSnapshotArchive(Boolean targetSnapshotArchive) {
    this.targetSnapshotArchive = targetSnapshotArchive;
    return this;
  }

   /**
   * If true, archival snapshots of the target data will be taken on the target cluster after successful sync completions.
   * @return targetSnapshotArchive
  **/
  @ApiModelProperty(value = "If true, archival snapshots of the target data will be taken on the target cluster after successful sync completions.")
  public Boolean isTargetSnapshotArchive() {
    return targetSnapshotArchive;
  }

  public void setTargetSnapshotArchive(Boolean targetSnapshotArchive) {
    this.targetSnapshotArchive = targetSnapshotArchive;
  }

  public SyncPolicyExtendedExtended targetSnapshotExpiration(Integer targetSnapshotExpiration) {
    this.targetSnapshotExpiration = targetSnapshotExpiration;
    return this;
  }

   /**
   * The length of time in seconds to keep snapshots on the target cluster.
   * minimum: 0
   * @return targetSnapshotExpiration
  **/
  @ApiModelProperty(value = "The length of time in seconds to keep snapshots on the target cluster.")
  public Integer getTargetSnapshotExpiration() {
    return targetSnapshotExpiration;
  }

  public void setTargetSnapshotExpiration(Integer targetSnapshotExpiration) {
    this.targetSnapshotExpiration = targetSnapshotExpiration;
  }

  public SyncPolicyExtendedExtended targetSnapshotPattern(String targetSnapshotPattern) {
    this.targetSnapshotPattern = targetSnapshotPattern;
    return this;
  }

   /**
   * The name pattern for snapshots taken on the target cluster after the sync completes.  A value of @DEFAULT will reset this field to the default creation value.
   * @return targetSnapshotPattern
  **/
  @ApiModelProperty(value = "The name pattern for snapshots taken on the target cluster after the sync completes.  A value of @DEFAULT will reset this field to the default creation value.")
  public String getTargetSnapshotPattern() {
    return targetSnapshotPattern;
  }

  public void setTargetSnapshotPattern(String targetSnapshotPattern) {
    this.targetSnapshotPattern = targetSnapshotPattern;
  }

  public SyncPolicyExtendedExtended workersPerNode(Integer workersPerNode) {
    this.workersPerNode = workersPerNode;
    return this;
  }

   /**
   * The number of worker threads on a node performing a sync.
   * minimum: 1
   * maximum: 20
   * @return workersPerNode
  **/
  @ApiModelProperty(value = "The number of worker threads on a node performing a sync.")
  public Integer getWorkersPerNode() {
    return workersPerNode;
  }

  public void setWorkersPerNode(Integer workersPerNode) {
    this.workersPerNode = workersPerNode;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SyncPolicyExtendedExtended syncPolicyExtendedExtended = (SyncPolicyExtendedExtended) o;
    return Objects.equals(this.acceleratedFailback, syncPolicyExtendedExtended.acceleratedFailback) &&
        Objects.equals(this.action, syncPolicyExtendedExtended.action) &&
        Objects.equals(this.burstMode, syncPolicyExtendedExtended.burstMode) &&
        Objects.equals(this.changelist, syncPolicyExtendedExtended.changelist) &&
        Objects.equals(this.checkIntegrity, syncPolicyExtendedExtended.checkIntegrity) &&
        Objects.equals(this.cloudDeepCopy, syncPolicyExtendedExtended.cloudDeepCopy) &&
        Objects.equals(this.conflicted, syncPolicyExtendedExtended.conflicted) &&
        Objects.equals(this.description, syncPolicyExtendedExtended.description) &&
        Objects.equals(this.disableFileSplit, syncPolicyExtendedExtended.disableFileSplit) &&
        Objects.equals(this.disableFofb, syncPolicyExtendedExtended.disableFofb) &&
        Objects.equals(this.disableStf, syncPolicyExtendedExtended.disableStf) &&
        Objects.equals(this.enabled, syncPolicyExtendedExtended.enabled) &&
        Objects.equals(this.expectedDataloss, syncPolicyExtendedExtended.expectedDataloss) &&
        Objects.equals(this.fileMatchingPattern, syncPolicyExtendedExtended.fileMatchingPattern) &&
        Objects.equals(this.forceInterface, syncPolicyExtendedExtended.forceInterface) &&
        Objects.equals(this.hasSyncState, syncPolicyExtendedExtended.hasSyncState) &&
        Objects.equals(this.id, syncPolicyExtendedExtended.id) &&
        Objects.equals(this.jobDelay, syncPolicyExtendedExtended.jobDelay) &&
        Objects.equals(this.lastJobState, syncPolicyExtendedExtended.lastJobState) &&
        Objects.equals(this.lastStarted, syncPolicyExtendedExtended.lastStarted) &&
        Objects.equals(this.lastSuccess, syncPolicyExtendedExtended.lastSuccess) &&
        Objects.equals(this.logLevel, syncPolicyExtendedExtended.logLevel) &&
        Objects.equals(this.logRemovedFiles, syncPolicyExtendedExtended.logRemovedFiles) &&
        Objects.equals(this.name, syncPolicyExtendedExtended.name) &&
        Objects.equals(this.nextRun, syncPolicyExtendedExtended.nextRun) &&
        Objects.equals(this.passwordSet, syncPolicyExtendedExtended.passwordSet) &&
        Objects.equals(this.priority, syncPolicyExtendedExtended.priority) &&
        Objects.equals(this.reportMaxAge, syncPolicyExtendedExtended.reportMaxAge) &&
        Objects.equals(this.reportMaxCount, syncPolicyExtendedExtended.reportMaxCount) &&
        Objects.equals(this.restrictTargetNetwork, syncPolicyExtendedExtended.restrictTargetNetwork) &&
        Objects.equals(this.rpoAlert, syncPolicyExtendedExtended.rpoAlert) &&
        Objects.equals(this.schedule, syncPolicyExtendedExtended.schedule) &&
        Objects.equals(this.skipLookup, syncPolicyExtendedExtended.skipLookup) &&
        Objects.equals(this.skipWhenSourceUnmodified, syncPolicyExtendedExtended.skipWhenSourceUnmodified) &&
        Objects.equals(this.snapshotSyncExisting, syncPolicyExtendedExtended.snapshotSyncExisting) &&
        Objects.equals(this.snapshotSyncPattern, syncPolicyExtendedExtended.snapshotSyncPattern) &&
        Objects.equals(this.sourceExcludeDirectories, syncPolicyExtendedExtended.sourceExcludeDirectories) &&
        Objects.equals(this.sourceIncludeDirectories, syncPolicyExtendedExtended.sourceIncludeDirectories) &&
        Objects.equals(this.sourceNetwork, syncPolicyExtendedExtended.sourceNetwork) &&
        Objects.equals(this.sourceRootPath, syncPolicyExtendedExtended.sourceRootPath) &&
        Objects.equals(this.sourceSnapshotArchive, syncPolicyExtendedExtended.sourceSnapshotArchive) &&
        Objects.equals(this.sourceSnapshotExpiration, syncPolicyExtendedExtended.sourceSnapshotExpiration) &&
        Objects.equals(this.sourceSnapshotPattern, syncPolicyExtendedExtended.sourceSnapshotPattern) &&
        Objects.equals(this.targetCompareInitialSync, syncPolicyExtendedExtended.targetCompareInitialSync) &&
        Objects.equals(this.targetDetectModifications, syncPolicyExtendedExtended.targetDetectModifications) &&
        Objects.equals(this.targetHost, syncPolicyExtendedExtended.targetHost) &&
        Objects.equals(this.targetPath, syncPolicyExtendedExtended.targetPath) &&
        Objects.equals(this.targetSnapshotAlias, syncPolicyExtendedExtended.targetSnapshotAlias) &&
        Objects.equals(this.targetSnapshotArchive, syncPolicyExtendedExtended.targetSnapshotArchive) &&
        Objects.equals(this.targetSnapshotExpiration, syncPolicyExtendedExtended.targetSnapshotExpiration) &&
        Objects.equals(this.targetSnapshotPattern, syncPolicyExtendedExtended.targetSnapshotPattern) &&
        Objects.equals(this.workersPerNode, syncPolicyExtendedExtended.workersPerNode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceleratedFailback, action, burstMode, changelist, checkIntegrity, cloudDeepCopy, conflicted, description, disableFileSplit, disableFofb, disableStf, enabled, expectedDataloss, fileMatchingPattern, forceInterface, hasSyncState, id, jobDelay, lastJobState, lastStarted, lastSuccess, logLevel, logRemovedFiles, name, nextRun, passwordSet, priority, reportMaxAge, reportMaxCount, restrictTargetNetwork, rpoAlert, schedule, skipLookup, skipWhenSourceUnmodified, snapshotSyncExisting, snapshotSyncPattern, sourceExcludeDirectories, sourceIncludeDirectories, sourceNetwork, sourceRootPath, sourceSnapshotArchive, sourceSnapshotExpiration, sourceSnapshotPattern, targetCompareInitialSync, targetDetectModifications, targetHost, targetPath, targetSnapshotAlias, targetSnapshotArchive, targetSnapshotExpiration, targetSnapshotPattern, workersPerNode);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SyncPolicyExtendedExtended {\n");
    
    sb.append("    acceleratedFailback: ").append(toIndentedString(acceleratedFailback)).append("\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    burstMode: ").append(toIndentedString(burstMode)).append("\n");
    sb.append("    changelist: ").append(toIndentedString(changelist)).append("\n");
    sb.append("    checkIntegrity: ").append(toIndentedString(checkIntegrity)).append("\n");
    sb.append("    cloudDeepCopy: ").append(toIndentedString(cloudDeepCopy)).append("\n");
    sb.append("    conflicted: ").append(toIndentedString(conflicted)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    disableFileSplit: ").append(toIndentedString(disableFileSplit)).append("\n");
    sb.append("    disableFofb: ").append(toIndentedString(disableFofb)).append("\n");
    sb.append("    disableStf: ").append(toIndentedString(disableStf)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    expectedDataloss: ").append(toIndentedString(expectedDataloss)).append("\n");
    sb.append("    fileMatchingPattern: ").append(toIndentedString(fileMatchingPattern)).append("\n");
    sb.append("    forceInterface: ").append(toIndentedString(forceInterface)).append("\n");
    sb.append("    hasSyncState: ").append(toIndentedString(hasSyncState)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    jobDelay: ").append(toIndentedString(jobDelay)).append("\n");
    sb.append("    lastJobState: ").append(toIndentedString(lastJobState)).append("\n");
    sb.append("    lastStarted: ").append(toIndentedString(lastStarted)).append("\n");
    sb.append("    lastSuccess: ").append(toIndentedString(lastSuccess)).append("\n");
    sb.append("    logLevel: ").append(toIndentedString(logLevel)).append("\n");
    sb.append("    logRemovedFiles: ").append(toIndentedString(logRemovedFiles)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nextRun: ").append(toIndentedString(nextRun)).append("\n");
    sb.append("    passwordSet: ").append(toIndentedString(passwordSet)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    reportMaxAge: ").append(toIndentedString(reportMaxAge)).append("\n");
    sb.append("    reportMaxCount: ").append(toIndentedString(reportMaxCount)).append("\n");
    sb.append("    restrictTargetNetwork: ").append(toIndentedString(restrictTargetNetwork)).append("\n");
    sb.append("    rpoAlert: ").append(toIndentedString(rpoAlert)).append("\n");
    sb.append("    schedule: ").append(toIndentedString(schedule)).append("\n");
    sb.append("    skipLookup: ").append(toIndentedString(skipLookup)).append("\n");
    sb.append("    skipWhenSourceUnmodified: ").append(toIndentedString(skipWhenSourceUnmodified)).append("\n");
    sb.append("    snapshotSyncExisting: ").append(toIndentedString(snapshotSyncExisting)).append("\n");
    sb.append("    snapshotSyncPattern: ").append(toIndentedString(snapshotSyncPattern)).append("\n");
    sb.append("    sourceExcludeDirectories: ").append(toIndentedString(sourceExcludeDirectories)).append("\n");
    sb.append("    sourceIncludeDirectories: ").append(toIndentedString(sourceIncludeDirectories)).append("\n");
    sb.append("    sourceNetwork: ").append(toIndentedString(sourceNetwork)).append("\n");
    sb.append("    sourceRootPath: ").append(toIndentedString(sourceRootPath)).append("\n");
    sb.append("    sourceSnapshotArchive: ").append(toIndentedString(sourceSnapshotArchive)).append("\n");
    sb.append("    sourceSnapshotExpiration: ").append(toIndentedString(sourceSnapshotExpiration)).append("\n");
    sb.append("    sourceSnapshotPattern: ").append(toIndentedString(sourceSnapshotPattern)).append("\n");
    sb.append("    targetCompareInitialSync: ").append(toIndentedString(targetCompareInitialSync)).append("\n");
    sb.append("    targetDetectModifications: ").append(toIndentedString(targetDetectModifications)).append("\n");
    sb.append("    targetHost: ").append(toIndentedString(targetHost)).append("\n");
    sb.append("    targetPath: ").append(toIndentedString(targetPath)).append("\n");
    sb.append("    targetSnapshotAlias: ").append(toIndentedString(targetSnapshotAlias)).append("\n");
    sb.append("    targetSnapshotArchive: ").append(toIndentedString(targetSnapshotArchive)).append("\n");
    sb.append("    targetSnapshotExpiration: ").append(toIndentedString(targetSnapshotExpiration)).append("\n");
    sb.append("    targetSnapshotPattern: ").append(toIndentedString(targetSnapshotPattern)).append("\n");
    sb.append("    workersPerNode: ").append(toIndentedString(workersPerNode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

