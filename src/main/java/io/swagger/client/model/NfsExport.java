/*
 * Isilon SDK
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.NfsSettingsExportSettingsMapAll;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * Specifies configuration values for NFS exports.
 */
@ApiModel(description = "Specifies configuration values for NFS exports.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-04-19T15:41:52.549-07:00")
public class NfsExport {
  @SerializedName("all_dirs")
  private Boolean allDirs = null;

  @SerializedName("block_size")
  private Integer blockSize = null;

  @SerializedName("can_set_time")
  private Boolean canSetTime = null;

  @SerializedName("case_insensitive")
  private Boolean caseInsensitive = null;

  @SerializedName("case_preserving")
  private Boolean casePreserving = null;

  @SerializedName("chown_restricted")
  private Boolean chownRestricted = null;

  @SerializedName("clients")
  private List<String> clients = null;

  @SerializedName("commit_asynchronous")
  private Boolean commitAsynchronous = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("directory_transfer_size")
  private Integer directoryTransferSize = null;

  @SerializedName("encoding")
  private String encoding = null;

  @SerializedName("link_max")
  private Integer linkMax = null;

  @SerializedName("map_all")
  private NfsSettingsExportSettingsMapAll mapAll = null;

  @SerializedName("map_failure")
  private NfsSettingsExportSettingsMapAll mapFailure = null;

  @SerializedName("map_full")
  private Boolean mapFull = null;

  @SerializedName("map_lookup_uid")
  private Boolean mapLookupUid = null;

  @SerializedName("map_non_root")
  private NfsSettingsExportSettingsMapAll mapNonRoot = null;

  @SerializedName("map_retry")
  private Boolean mapRetry = null;

  @SerializedName("map_root")
  private NfsSettingsExportSettingsMapAll mapRoot = null;

  @SerializedName("max_file_size")
  private Integer maxFileSize = null;

  @SerializedName("name_max_size")
  private Integer nameMaxSize = null;

  @SerializedName("no_truncate")
  private Boolean noTruncate = null;

  @SerializedName("paths")
  private List<String> paths = null;

  @SerializedName("read_only")
  private Boolean readOnly = null;

  @SerializedName("read_only_clients")
  private List<String> readOnlyClients = null;

  @SerializedName("read_transfer_max_size")
  private Integer readTransferMaxSize = null;

  @SerializedName("read_transfer_multiple")
  private Integer readTransferMultiple = null;

  @SerializedName("read_transfer_size")
  private Integer readTransferSize = null;

  @SerializedName("read_write_clients")
  private List<String> readWriteClients = null;

  @SerializedName("readdirplus")
  private Boolean readdirplus = null;

  @SerializedName("readdirplus_prefetch")
  private Integer readdirplusPrefetch = null;

  @SerializedName("return_32bit_file_ids")
  private Boolean return32bitFileIds = null;

  @SerializedName("root_clients")
  private List<String> rootClients = null;

  /**
   * Specifies the authentication types that are supported for this export.
   */
  @JsonAdapter(SecurityFlavorsEnum.Adapter.class)
  public enum SecurityFlavorsEnum {
    UNIX("unix"),
    
    KRB5("krb5"),
    
    KRB5I("krb5i"),
    
    KRB5P("krb5p");

    private String value;

    SecurityFlavorsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecurityFlavorsEnum fromValue(String text) {
      for (SecurityFlavorsEnum b : SecurityFlavorsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<SecurityFlavorsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecurityFlavorsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecurityFlavorsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SecurityFlavorsEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("security_flavors")
  private List<SecurityFlavorsEnum> securityFlavors = null;

  @SerializedName("setattr_asynchronous")
  private Boolean setattrAsynchronous = null;

  @SerializedName("snapshot")
  private String snapshot = null;

  @SerializedName("symlinks")
  private Boolean symlinks = null;

  @SerializedName("time_delta")
  private BigDecimal timeDelta = null;

  @SerializedName("write_datasync_action")
  private String writeDatasyncAction = null;

  @SerializedName("write_datasync_reply")
  private String writeDatasyncReply = null;

  @SerializedName("write_filesync_action")
  private String writeFilesyncAction = null;

  @SerializedName("write_filesync_reply")
  private String writeFilesyncReply = null;

  @SerializedName("write_transfer_max_size")
  private Integer writeTransferMaxSize = null;

  @SerializedName("write_transfer_multiple")
  private Integer writeTransferMultiple = null;

  @SerializedName("write_transfer_size")
  private Integer writeTransferSize = null;

  @SerializedName("write_unstable_action")
  private String writeUnstableAction = null;

  @SerializedName("write_unstable_reply")
  private String writeUnstableReply = null;

  @SerializedName("zone")
  private String zone = null;

  public NfsExport allDirs(Boolean allDirs) {
    this.allDirs = allDirs;
    return this;
  }

   /**
   * True if all directories under the specified paths are mountable.
   * @return allDirs
  **/
  @ApiModelProperty(value = "True if all directories under the specified paths are mountable.")
  public Boolean isAllDirs() {
    return allDirs;
  }

  public void setAllDirs(Boolean allDirs) {
    this.allDirs = allDirs;
  }

  public NfsExport blockSize(Integer blockSize) {
    this.blockSize = blockSize;
    return this;
  }

   /**
   * Specifies the block size returned by the NFS statfs procedure.
   * @return blockSize
  **/
  @ApiModelProperty(value = "Specifies the block size returned by the NFS statfs procedure.")
  public Integer getBlockSize() {
    return blockSize;
  }

  public void setBlockSize(Integer blockSize) {
    this.blockSize = blockSize;
  }

  public NfsExport canSetTime(Boolean canSetTime) {
    this.canSetTime = canSetTime;
    return this;
  }

   /**
   * True if the client can set file times through the NFS set attribute request. This parameter does not affect server behavior, but is included to accommoate legacy client requirements.
   * @return canSetTime
  **/
  @ApiModelProperty(value = "True if the client can set file times through the NFS set attribute request. This parameter does not affect server behavior, but is included to accommoate legacy client requirements.")
  public Boolean isCanSetTime() {
    return canSetTime;
  }

  public void setCanSetTime(Boolean canSetTime) {
    this.canSetTime = canSetTime;
  }

  public NfsExport caseInsensitive(Boolean caseInsensitive) {
    this.caseInsensitive = caseInsensitive;
    return this;
  }

   /**
   * True if the case is ignored for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return caseInsensitive
  **/
  @ApiModelProperty(value = "True if the case is ignored for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Boolean isCaseInsensitive() {
    return caseInsensitive;
  }

  public void setCaseInsensitive(Boolean caseInsensitive) {
    this.caseInsensitive = caseInsensitive;
  }

  public NfsExport casePreserving(Boolean casePreserving) {
    this.casePreserving = casePreserving;
    return this;
  }

   /**
   * True if the case is preserved for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return casePreserving
  **/
  @ApiModelProperty(value = "True if the case is preserved for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Boolean isCasePreserving() {
    return casePreserving;
  }

  public void setCasePreserving(Boolean casePreserving) {
    this.casePreserving = casePreserving;
  }

  public NfsExport chownRestricted(Boolean chownRestricted) {
    this.chownRestricted = chownRestricted;
    return this;
  }

   /**
   * True if the superuser can change file ownership. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return chownRestricted
  **/
  @ApiModelProperty(value = "True if the superuser can change file ownership. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Boolean isChownRestricted() {
    return chownRestricted;
  }

  public void setChownRestricted(Boolean chownRestricted) {
    this.chownRestricted = chownRestricted;
  }

  public NfsExport clients(List<String> clients) {
    this.clients = clients;
    return this;
  }

  public NfsExport addClientsItem(String clientsItem) {
    if (this.clients == null) {
      this.clients = new ArrayList<String>();
    }
    this.clients.add(clientsItem);
    return this;
  }

   /**
   * Specifies the clients with root access to the export.
   * @return clients
  **/
  @ApiModelProperty(value = "Specifies the clients with root access to the export.")
  public List<String> getClients() {
    return clients;
  }

  public void setClients(List<String> clients) {
    this.clients = clients;
  }

  public NfsExport commitAsynchronous(Boolean commitAsynchronous) {
    this.commitAsynchronous = commitAsynchronous;
    return this;
  }

   /**
   * True if NFS  commit  requests execute asynchronously.
   * @return commitAsynchronous
  **/
  @ApiModelProperty(value = "True if NFS  commit  requests execute asynchronously.")
  public Boolean isCommitAsynchronous() {
    return commitAsynchronous;
  }

  public void setCommitAsynchronous(Boolean commitAsynchronous) {
    this.commitAsynchronous = commitAsynchronous;
  }

  public NfsExport description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Specifies the user-defined string that is used to identify the export.
   * @return description
  **/
  @ApiModelProperty(value = "Specifies the user-defined string that is used to identify the export.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public NfsExport directoryTransferSize(Integer directoryTransferSize) {
    this.directoryTransferSize = directoryTransferSize;
    return this;
  }

   /**
   * Specifies the preferred size for directory read operations. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return directoryTransferSize
  **/
  @ApiModelProperty(value = "Specifies the preferred size for directory read operations. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getDirectoryTransferSize() {
    return directoryTransferSize;
  }

  public void setDirectoryTransferSize(Integer directoryTransferSize) {
    this.directoryTransferSize = directoryTransferSize;
  }

  public NfsExport encoding(String encoding) {
    this.encoding = encoding;
    return this;
  }

   /**
   * Specifies the default character set encoding of the clients connecting to the export, unless otherwise specified.
   * @return encoding
  **/
  @ApiModelProperty(value = "Specifies the default character set encoding of the clients connecting to the export, unless otherwise specified.")
  public String getEncoding() {
    return encoding;
  }

  public void setEncoding(String encoding) {
    this.encoding = encoding;
  }

  public NfsExport linkMax(Integer linkMax) {
    this.linkMax = linkMax;
    return this;
  }

   /**
   * Specifies the reported maximum number of links to a file. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return linkMax
  **/
  @ApiModelProperty(value = "Specifies the reported maximum number of links to a file. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Integer getLinkMax() {
    return linkMax;
  }

  public void setLinkMax(Integer linkMax) {
    this.linkMax = linkMax;
  }

  public NfsExport mapAll(NfsSettingsExportSettingsMapAll mapAll) {
    this.mapAll = mapAll;
    return this;
  }

   /**
   * User and group mapping.
   * @return mapAll
  **/
  @ApiModelProperty(value = "User and group mapping.")
  public NfsSettingsExportSettingsMapAll getMapAll() {
    return mapAll;
  }

  public void setMapAll(NfsSettingsExportSettingsMapAll mapAll) {
    this.mapAll = mapAll;
  }

  public NfsExport mapFailure(NfsSettingsExportSettingsMapAll mapFailure) {
    this.mapFailure = mapFailure;
    return this;
  }

   /**
   * User and group mapping.
   * @return mapFailure
  **/
  @ApiModelProperty(value = "User and group mapping.")
  public NfsSettingsExportSettingsMapAll getMapFailure() {
    return mapFailure;
  }

  public void setMapFailure(NfsSettingsExportSettingsMapAll mapFailure) {
    this.mapFailure = mapFailure;
  }

  public NfsExport mapFull(Boolean mapFull) {
    this.mapFull = mapFull;
    return this;
  }

   /**
   * True if user mappings query the OneFS user database. When set to false, user mappings only query local authentication.
   * @return mapFull
  **/
  @ApiModelProperty(value = "True if user mappings query the OneFS user database. When set to false, user mappings only query local authentication.")
  public Boolean isMapFull() {
    return mapFull;
  }

  public void setMapFull(Boolean mapFull) {
    this.mapFull = mapFull;
  }

  public NfsExport mapLookupUid(Boolean mapLookupUid) {
    this.mapLookupUid = mapLookupUid;
    return this;
  }

   /**
   * True if incoming user IDs (UIDs) are mapped to users in the OneFS user database. When set to false, incoming UIDs are applied directly to file operations.
   * @return mapLookupUid
  **/
  @ApiModelProperty(value = "True if incoming user IDs (UIDs) are mapped to users in the OneFS user database. When set to false, incoming UIDs are applied directly to file operations.")
  public Boolean isMapLookupUid() {
    return mapLookupUid;
  }

  public void setMapLookupUid(Boolean mapLookupUid) {
    this.mapLookupUid = mapLookupUid;
  }

  public NfsExport mapNonRoot(NfsSettingsExportSettingsMapAll mapNonRoot) {
    this.mapNonRoot = mapNonRoot;
    return this;
  }

   /**
   * User and group mapping.
   * @return mapNonRoot
  **/
  @ApiModelProperty(value = "User and group mapping.")
  public NfsSettingsExportSettingsMapAll getMapNonRoot() {
    return mapNonRoot;
  }

  public void setMapNonRoot(NfsSettingsExportSettingsMapAll mapNonRoot) {
    this.mapNonRoot = mapNonRoot;
  }

  public NfsExport mapRetry(Boolean mapRetry) {
    this.mapRetry = mapRetry;
    return this;
  }

   /**
   * Determines whether searches for users specified in &#39;map_all&#39;, &#39;map_root&#39; or &#39;map_nonroot&#39; are retried if the search fails.
   * @return mapRetry
  **/
  @ApiModelProperty(value = "Determines whether searches for users specified in 'map_all', 'map_root' or 'map_nonroot' are retried if the search fails.")
  public Boolean isMapRetry() {
    return mapRetry;
  }

  public void setMapRetry(Boolean mapRetry) {
    this.mapRetry = mapRetry;
  }

  public NfsExport mapRoot(NfsSettingsExportSettingsMapAll mapRoot) {
    this.mapRoot = mapRoot;
    return this;
  }

   /**
   * User and group mapping.
   * @return mapRoot
  **/
  @ApiModelProperty(value = "User and group mapping.")
  public NfsSettingsExportSettingsMapAll getMapRoot() {
    return mapRoot;
  }

  public void setMapRoot(NfsSettingsExportSettingsMapAll mapRoot) {
    this.mapRoot = mapRoot;
  }

  public NfsExport maxFileSize(Integer maxFileSize) {
    this.maxFileSize = maxFileSize;
    return this;
  }

   /**
   * Specifies the maximum file size for any file accessed from the export. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return maxFileSize
  **/
  @ApiModelProperty(value = "Specifies the maximum file size for any file accessed from the export. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Integer getMaxFileSize() {
    return maxFileSize;
  }

  public void setMaxFileSize(Integer maxFileSize) {
    this.maxFileSize = maxFileSize;
  }

  public NfsExport nameMaxSize(Integer nameMaxSize) {
    this.nameMaxSize = nameMaxSize;
    return this;
  }

   /**
   * Specifies the reported maximum length of a file name. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return nameMaxSize
  **/
  @ApiModelProperty(value = "Specifies the reported maximum length of a file name. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Integer getNameMaxSize() {
    return nameMaxSize;
  }

  public void setNameMaxSize(Integer nameMaxSize) {
    this.nameMaxSize = nameMaxSize;
  }

  public NfsExport noTruncate(Boolean noTruncate) {
    this.noTruncate = noTruncate;
    return this;
  }

   /**
   * True if long file names result in an error. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
   * @return noTruncate
  **/
  @ApiModelProperty(value = "True if long file names result in an error. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.")
  public Boolean isNoTruncate() {
    return noTruncate;
  }

  public void setNoTruncate(Boolean noTruncate) {
    this.noTruncate = noTruncate;
  }

  public NfsExport paths(List<String> paths) {
    this.paths = paths;
    return this;
  }

  public NfsExport addPathsItem(String pathsItem) {
    if (this.paths == null) {
      this.paths = new ArrayList<String>();
    }
    this.paths.add(pathsItem);
    return this;
  }

   /**
   * Specifies the paths under /ifs that are exported.
   * @return paths
  **/
  @ApiModelProperty(value = "Specifies the paths under /ifs that are exported.")
  public List<String> getPaths() {
    return paths;
  }

  public void setPaths(List<String> paths) {
    this.paths = paths;
  }

  public NfsExport readOnly(Boolean readOnly) {
    this.readOnly = readOnly;
    return this;
  }

   /**
   * True if the export is set to read-only.
   * @return readOnly
  **/
  @ApiModelProperty(value = "True if the export is set to read-only.")
  public Boolean isReadOnly() {
    return readOnly;
  }

  public void setReadOnly(Boolean readOnly) {
    this.readOnly = readOnly;
  }

  public NfsExport readOnlyClients(List<String> readOnlyClients) {
    this.readOnlyClients = readOnlyClients;
    return this;
  }

  public NfsExport addReadOnlyClientsItem(String readOnlyClientsItem) {
    if (this.readOnlyClients == null) {
      this.readOnlyClients = new ArrayList<String>();
    }
    this.readOnlyClients.add(readOnlyClientsItem);
    return this;
  }

   /**
   * Specifies the clients with read-only access to the export.
   * @return readOnlyClients
  **/
  @ApiModelProperty(value = "Specifies the clients with read-only access to the export.")
  public List<String> getReadOnlyClients() {
    return readOnlyClients;
  }

  public void setReadOnlyClients(List<String> readOnlyClients) {
    this.readOnlyClients = readOnlyClients;
  }

  public NfsExport readTransferMaxSize(Integer readTransferMaxSize) {
    this.readTransferMaxSize = readTransferMaxSize;
    return this;
  }

   /**
   * Specifies the maximum buffer size that clients should use on NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return readTransferMaxSize
  **/
  @ApiModelProperty(value = "Specifies the maximum buffer size that clients should use on NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getReadTransferMaxSize() {
    return readTransferMaxSize;
  }

  public void setReadTransferMaxSize(Integer readTransferMaxSize) {
    this.readTransferMaxSize = readTransferMaxSize;
  }

  public NfsExport readTransferMultiple(Integer readTransferMultiple) {
    this.readTransferMultiple = readTransferMultiple;
    return this;
  }

   /**
   * Specifies the preferred multiple size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return readTransferMultiple
  **/
  @ApiModelProperty(value = "Specifies the preferred multiple size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getReadTransferMultiple() {
    return readTransferMultiple;
  }

  public void setReadTransferMultiple(Integer readTransferMultiple) {
    this.readTransferMultiple = readTransferMultiple;
  }

  public NfsExport readTransferSize(Integer readTransferSize) {
    this.readTransferSize = readTransferSize;
    return this;
  }

   /**
   * Specifies the preferred size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return readTransferSize
  **/
  @ApiModelProperty(value = "Specifies the preferred size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getReadTransferSize() {
    return readTransferSize;
  }

  public void setReadTransferSize(Integer readTransferSize) {
    this.readTransferSize = readTransferSize;
  }

  public NfsExport readWriteClients(List<String> readWriteClients) {
    this.readWriteClients = readWriteClients;
    return this;
  }

  public NfsExport addReadWriteClientsItem(String readWriteClientsItem) {
    if (this.readWriteClients == null) {
      this.readWriteClients = new ArrayList<String>();
    }
    this.readWriteClients.add(readWriteClientsItem);
    return this;
  }

   /**
   * Specifies the clients with both read and write access to the export, even when the export is set to read-only.
   * @return readWriteClients
  **/
  @ApiModelProperty(value = "Specifies the clients with both read and write access to the export, even when the export is set to read-only.")
  public List<String> getReadWriteClients() {
    return readWriteClients;
  }

  public void setReadWriteClients(List<String> readWriteClients) {
    this.readWriteClients = readWriteClients;
  }

  public NfsExport readdirplus(Boolean readdirplus) {
    this.readdirplus = readdirplus;
    return this;
  }

   /**
   * True if &#39;readdirplus&#39; requests are enabled. Enabling this property might improve network performance and is only available for NFSv3.
   * @return readdirplus
  **/
  @ApiModelProperty(value = "True if 'readdirplus' requests are enabled. Enabling this property might improve network performance and is only available for NFSv3.")
  public Boolean isReaddirplus() {
    return readdirplus;
  }

  public void setReaddirplus(Boolean readdirplus) {
    this.readdirplus = readdirplus;
  }

  public NfsExport readdirplusPrefetch(Integer readdirplusPrefetch) {
    this.readdirplusPrefetch = readdirplusPrefetch;
    return this;
  }

   /**
   * Sets the number of directory entries that are prefetched when a &#39;readdirplus&#39; request is processed. (Deprecated.)
   * @return readdirplusPrefetch
  **/
  @ApiModelProperty(value = "Sets the number of directory entries that are prefetched when a 'readdirplus' request is processed. (Deprecated.)")
  public Integer getReaddirplusPrefetch() {
    return readdirplusPrefetch;
  }

  public void setReaddirplusPrefetch(Integer readdirplusPrefetch) {
    this.readdirplusPrefetch = readdirplusPrefetch;
  }

  public NfsExport return32bitFileIds(Boolean return32bitFileIds) {
    this.return32bitFileIds = return32bitFileIds;
    return this;
  }

   /**
   * Limits the size of file identifiers returned by NFSv3+ to 32-bit values (may require remount).
   * @return return32bitFileIds
  **/
  @ApiModelProperty(value = "Limits the size of file identifiers returned by NFSv3+ to 32-bit values (may require remount).")
  public Boolean isReturn32bitFileIds() {
    return return32bitFileIds;
  }

  public void setReturn32bitFileIds(Boolean return32bitFileIds) {
    this.return32bitFileIds = return32bitFileIds;
  }

  public NfsExport rootClients(List<String> rootClients) {
    this.rootClients = rootClients;
    return this;
  }

  public NfsExport addRootClientsItem(String rootClientsItem) {
    if (this.rootClients == null) {
      this.rootClients = new ArrayList<String>();
    }
    this.rootClients.add(rootClientsItem);
    return this;
  }

   /**
   * Clients that have root access to the export.
   * @return rootClients
  **/
  @ApiModelProperty(value = "Clients that have root access to the export.")
  public List<String> getRootClients() {
    return rootClients;
  }

  public void setRootClients(List<String> rootClients) {
    this.rootClients = rootClients;
  }

  public NfsExport securityFlavors(List<SecurityFlavorsEnum> securityFlavors) {
    this.securityFlavors = securityFlavors;
    return this;
  }

  public NfsExport addSecurityFlavorsItem(SecurityFlavorsEnum securityFlavorsItem) {
    if (this.securityFlavors == null) {
      this.securityFlavors = new ArrayList<SecurityFlavorsEnum>();
    }
    this.securityFlavors.add(securityFlavorsItem);
    return this;
  }

   /**
   * Specifies the authentication types that are supported for this export.
   * @return securityFlavors
  **/
  @ApiModelProperty(value = "Specifies the authentication types that are supported for this export.")
  public List<SecurityFlavorsEnum> getSecurityFlavors() {
    return securityFlavors;
  }

  public void setSecurityFlavors(List<SecurityFlavorsEnum> securityFlavors) {
    this.securityFlavors = securityFlavors;
  }

  public NfsExport setattrAsynchronous(Boolean setattrAsynchronous) {
    this.setattrAsynchronous = setattrAsynchronous;
    return this;
  }

   /**
   * True if set attribute operations execute asynchronously.
   * @return setattrAsynchronous
  **/
  @ApiModelProperty(value = "True if set attribute operations execute asynchronously.")
  public Boolean isSetattrAsynchronous() {
    return setattrAsynchronous;
  }

  public void setSetattrAsynchronous(Boolean setattrAsynchronous) {
    this.setattrAsynchronous = setattrAsynchronous;
  }

  public NfsExport snapshot(String snapshot) {
    this.snapshot = snapshot;
    return this;
  }

   /**
   * Specifies the snapshot for all mounts.
   * @return snapshot
  **/
  @ApiModelProperty(value = "Specifies the snapshot for all mounts.")
  public String getSnapshot() {
    return snapshot;
  }

  public void setSnapshot(String snapshot) {
    this.snapshot = snapshot;
  }

  public NfsExport symlinks(Boolean symlinks) {
    this.symlinks = symlinks;
    return this;
  }

   /**
   * True if symlinks are supported. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return symlinks
  **/
  @ApiModelProperty(value = "True if symlinks are supported. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Boolean isSymlinks() {
    return symlinks;
  }

  public void setSymlinks(Boolean symlinks) {
    this.symlinks = symlinks;
  }

  public NfsExport timeDelta(BigDecimal timeDelta) {
    this.timeDelta = timeDelta;
    return this;
  }

   /**
   * Specifies the resolution of all time values that are returned to the clients
   * @return timeDelta
  **/
  @ApiModelProperty(value = "Specifies the resolution of all time values that are returned to the clients")
  public BigDecimal getTimeDelta() {
    return timeDelta;
  }

  public void setTimeDelta(BigDecimal timeDelta) {
    this.timeDelta = timeDelta;
  }

  public NfsExport writeDatasyncAction(String writeDatasyncAction) {
    this.writeDatasyncAction = writeDatasyncAction;
    return this;
  }

   /**
   * Specifies the synchronization type.
   * @return writeDatasyncAction
  **/
  @ApiModelProperty(value = "Specifies the synchronization type.")
  public String getWriteDatasyncAction() {
    return writeDatasyncAction;
  }

  public void setWriteDatasyncAction(String writeDatasyncAction) {
    this.writeDatasyncAction = writeDatasyncAction;
  }

  public NfsExport writeDatasyncReply(String writeDatasyncReply) {
    this.writeDatasyncReply = writeDatasyncReply;
    return this;
  }

   /**
   * Specifies the synchronization type.
   * @return writeDatasyncReply
  **/
  @ApiModelProperty(value = "Specifies the synchronization type.")
  public String getWriteDatasyncReply() {
    return writeDatasyncReply;
  }

  public void setWriteDatasyncReply(String writeDatasyncReply) {
    this.writeDatasyncReply = writeDatasyncReply;
  }

  public NfsExport writeFilesyncAction(String writeFilesyncAction) {
    this.writeFilesyncAction = writeFilesyncAction;
    return this;
  }

   /**
   * Specifies the synchronization type.
   * @return writeFilesyncAction
  **/
  @ApiModelProperty(value = "Specifies the synchronization type.")
  public String getWriteFilesyncAction() {
    return writeFilesyncAction;
  }

  public void setWriteFilesyncAction(String writeFilesyncAction) {
    this.writeFilesyncAction = writeFilesyncAction;
  }

  public NfsExport writeFilesyncReply(String writeFilesyncReply) {
    this.writeFilesyncReply = writeFilesyncReply;
    return this;
  }

   /**
   * Specifies the synchronization type.
   * @return writeFilesyncReply
  **/
  @ApiModelProperty(value = "Specifies the synchronization type.")
  public String getWriteFilesyncReply() {
    return writeFilesyncReply;
  }

  public void setWriteFilesyncReply(String writeFilesyncReply) {
    this.writeFilesyncReply = writeFilesyncReply;
  }

  public NfsExport writeTransferMaxSize(Integer writeTransferMaxSize) {
    this.writeTransferMaxSize = writeTransferMaxSize;
    return this;
  }

   /**
   * Specifies the maximum buffer size that clients should use on NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return writeTransferMaxSize
  **/
  @ApiModelProperty(value = "Specifies the maximum buffer size that clients should use on NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getWriteTransferMaxSize() {
    return writeTransferMaxSize;
  }

  public void setWriteTransferMaxSize(Integer writeTransferMaxSize) {
    this.writeTransferMaxSize = writeTransferMaxSize;
  }

  public NfsExport writeTransferMultiple(Integer writeTransferMultiple) {
    this.writeTransferMultiple = writeTransferMultiple;
    return this;
  }

   /**
   * Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return writeTransferMultiple
  **/
  @ApiModelProperty(value = "Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getWriteTransferMultiple() {
    return writeTransferMultiple;
  }

  public void setWriteTransferMultiple(Integer writeTransferMultiple) {
    this.writeTransferMultiple = writeTransferMultiple;
  }

  public NfsExport writeTransferSize(Integer writeTransferSize) {
    this.writeTransferSize = writeTransferSize;
    return this;
  }

   /**
   * Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
   * @return writeTransferSize
  **/
  @ApiModelProperty(value = "Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.")
  public Integer getWriteTransferSize() {
    return writeTransferSize;
  }

  public void setWriteTransferSize(Integer writeTransferSize) {
    this.writeTransferSize = writeTransferSize;
  }

  public NfsExport writeUnstableAction(String writeUnstableAction) {
    this.writeUnstableAction = writeUnstableAction;
    return this;
  }

   /**
   * Specifies the synchronization type.
   * @return writeUnstableAction
  **/
  @ApiModelProperty(value = "Specifies the synchronization type.")
  public String getWriteUnstableAction() {
    return writeUnstableAction;
  }

  public void setWriteUnstableAction(String writeUnstableAction) {
    this.writeUnstableAction = writeUnstableAction;
  }

  public NfsExport writeUnstableReply(String writeUnstableReply) {
    this.writeUnstableReply = writeUnstableReply;
    return this;
  }

   /**
   * Specifies the synchronization type.
   * @return writeUnstableReply
  **/
  @ApiModelProperty(value = "Specifies the synchronization type.")
  public String getWriteUnstableReply() {
    return writeUnstableReply;
  }

  public void setWriteUnstableReply(String writeUnstableReply) {
    this.writeUnstableReply = writeUnstableReply;
  }

  public NfsExport zone(String zone) {
    this.zone = zone;
    return this;
  }

   /**
   * Specifies the zone in which the export is valid.
   * @return zone
  **/
  @ApiModelProperty(value = "Specifies the zone in which the export is valid.")
  public String getZone() {
    return zone;
  }

  public void setZone(String zone) {
    this.zone = zone;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    NfsExport nfsExport = (NfsExport) o;
    return Objects.equals(this.allDirs, nfsExport.allDirs) &&
        Objects.equals(this.blockSize, nfsExport.blockSize) &&
        Objects.equals(this.canSetTime, nfsExport.canSetTime) &&
        Objects.equals(this.caseInsensitive, nfsExport.caseInsensitive) &&
        Objects.equals(this.casePreserving, nfsExport.casePreserving) &&
        Objects.equals(this.chownRestricted, nfsExport.chownRestricted) &&
        Objects.equals(this.clients, nfsExport.clients) &&
        Objects.equals(this.commitAsynchronous, nfsExport.commitAsynchronous) &&
        Objects.equals(this.description, nfsExport.description) &&
        Objects.equals(this.directoryTransferSize, nfsExport.directoryTransferSize) &&
        Objects.equals(this.encoding, nfsExport.encoding) &&
        Objects.equals(this.linkMax, nfsExport.linkMax) &&
        Objects.equals(this.mapAll, nfsExport.mapAll) &&
        Objects.equals(this.mapFailure, nfsExport.mapFailure) &&
        Objects.equals(this.mapFull, nfsExport.mapFull) &&
        Objects.equals(this.mapLookupUid, nfsExport.mapLookupUid) &&
        Objects.equals(this.mapNonRoot, nfsExport.mapNonRoot) &&
        Objects.equals(this.mapRetry, nfsExport.mapRetry) &&
        Objects.equals(this.mapRoot, nfsExport.mapRoot) &&
        Objects.equals(this.maxFileSize, nfsExport.maxFileSize) &&
        Objects.equals(this.nameMaxSize, nfsExport.nameMaxSize) &&
        Objects.equals(this.noTruncate, nfsExport.noTruncate) &&
        Objects.equals(this.paths, nfsExport.paths) &&
        Objects.equals(this.readOnly, nfsExport.readOnly) &&
        Objects.equals(this.readOnlyClients, nfsExport.readOnlyClients) &&
        Objects.equals(this.readTransferMaxSize, nfsExport.readTransferMaxSize) &&
        Objects.equals(this.readTransferMultiple, nfsExport.readTransferMultiple) &&
        Objects.equals(this.readTransferSize, nfsExport.readTransferSize) &&
        Objects.equals(this.readWriteClients, nfsExport.readWriteClients) &&
        Objects.equals(this.readdirplus, nfsExport.readdirplus) &&
        Objects.equals(this.readdirplusPrefetch, nfsExport.readdirplusPrefetch) &&
        Objects.equals(this.return32bitFileIds, nfsExport.return32bitFileIds) &&
        Objects.equals(this.rootClients, nfsExport.rootClients) &&
        Objects.equals(this.securityFlavors, nfsExport.securityFlavors) &&
        Objects.equals(this.setattrAsynchronous, nfsExport.setattrAsynchronous) &&
        Objects.equals(this.snapshot, nfsExport.snapshot) &&
        Objects.equals(this.symlinks, nfsExport.symlinks) &&
        Objects.equals(this.timeDelta, nfsExport.timeDelta) &&
        Objects.equals(this.writeDatasyncAction, nfsExport.writeDatasyncAction) &&
        Objects.equals(this.writeDatasyncReply, nfsExport.writeDatasyncReply) &&
        Objects.equals(this.writeFilesyncAction, nfsExport.writeFilesyncAction) &&
        Objects.equals(this.writeFilesyncReply, nfsExport.writeFilesyncReply) &&
        Objects.equals(this.writeTransferMaxSize, nfsExport.writeTransferMaxSize) &&
        Objects.equals(this.writeTransferMultiple, nfsExport.writeTransferMultiple) &&
        Objects.equals(this.writeTransferSize, nfsExport.writeTransferSize) &&
        Objects.equals(this.writeUnstableAction, nfsExport.writeUnstableAction) &&
        Objects.equals(this.writeUnstableReply, nfsExport.writeUnstableReply) &&
        Objects.equals(this.zone, nfsExport.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allDirs, blockSize, canSetTime, caseInsensitive, casePreserving, chownRestricted, clients, commitAsynchronous, description, directoryTransferSize, encoding, linkMax, mapAll, mapFailure, mapFull, mapLookupUid, mapNonRoot, mapRetry, mapRoot, maxFileSize, nameMaxSize, noTruncate, paths, readOnly, readOnlyClients, readTransferMaxSize, readTransferMultiple, readTransferSize, readWriteClients, readdirplus, readdirplusPrefetch, return32bitFileIds, rootClients, securityFlavors, setattrAsynchronous, snapshot, symlinks, timeDelta, writeDatasyncAction, writeDatasyncReply, writeFilesyncAction, writeFilesyncReply, writeTransferMaxSize, writeTransferMultiple, writeTransferSize, writeUnstableAction, writeUnstableReply, zone);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class NfsExport {\n");
    
    sb.append("    allDirs: ").append(toIndentedString(allDirs)).append("\n");
    sb.append("    blockSize: ").append(toIndentedString(blockSize)).append("\n");
    sb.append("    canSetTime: ").append(toIndentedString(canSetTime)).append("\n");
    sb.append("    caseInsensitive: ").append(toIndentedString(caseInsensitive)).append("\n");
    sb.append("    casePreserving: ").append(toIndentedString(casePreserving)).append("\n");
    sb.append("    chownRestricted: ").append(toIndentedString(chownRestricted)).append("\n");
    sb.append("    clients: ").append(toIndentedString(clients)).append("\n");
    sb.append("    commitAsynchronous: ").append(toIndentedString(commitAsynchronous)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    directoryTransferSize: ").append(toIndentedString(directoryTransferSize)).append("\n");
    sb.append("    encoding: ").append(toIndentedString(encoding)).append("\n");
    sb.append("    linkMax: ").append(toIndentedString(linkMax)).append("\n");
    sb.append("    mapAll: ").append(toIndentedString(mapAll)).append("\n");
    sb.append("    mapFailure: ").append(toIndentedString(mapFailure)).append("\n");
    sb.append("    mapFull: ").append(toIndentedString(mapFull)).append("\n");
    sb.append("    mapLookupUid: ").append(toIndentedString(mapLookupUid)).append("\n");
    sb.append("    mapNonRoot: ").append(toIndentedString(mapNonRoot)).append("\n");
    sb.append("    mapRetry: ").append(toIndentedString(mapRetry)).append("\n");
    sb.append("    mapRoot: ").append(toIndentedString(mapRoot)).append("\n");
    sb.append("    maxFileSize: ").append(toIndentedString(maxFileSize)).append("\n");
    sb.append("    nameMaxSize: ").append(toIndentedString(nameMaxSize)).append("\n");
    sb.append("    noTruncate: ").append(toIndentedString(noTruncate)).append("\n");
    sb.append("    paths: ").append(toIndentedString(paths)).append("\n");
    sb.append("    readOnly: ").append(toIndentedString(readOnly)).append("\n");
    sb.append("    readOnlyClients: ").append(toIndentedString(readOnlyClients)).append("\n");
    sb.append("    readTransferMaxSize: ").append(toIndentedString(readTransferMaxSize)).append("\n");
    sb.append("    readTransferMultiple: ").append(toIndentedString(readTransferMultiple)).append("\n");
    sb.append("    readTransferSize: ").append(toIndentedString(readTransferSize)).append("\n");
    sb.append("    readWriteClients: ").append(toIndentedString(readWriteClients)).append("\n");
    sb.append("    readdirplus: ").append(toIndentedString(readdirplus)).append("\n");
    sb.append("    readdirplusPrefetch: ").append(toIndentedString(readdirplusPrefetch)).append("\n");
    sb.append("    return32bitFileIds: ").append(toIndentedString(return32bitFileIds)).append("\n");
    sb.append("    rootClients: ").append(toIndentedString(rootClients)).append("\n");
    sb.append("    securityFlavors: ").append(toIndentedString(securityFlavors)).append("\n");
    sb.append("    setattrAsynchronous: ").append(toIndentedString(setattrAsynchronous)).append("\n");
    sb.append("    snapshot: ").append(toIndentedString(snapshot)).append("\n");
    sb.append("    symlinks: ").append(toIndentedString(symlinks)).append("\n");
    sb.append("    timeDelta: ").append(toIndentedString(timeDelta)).append("\n");
    sb.append("    writeDatasyncAction: ").append(toIndentedString(writeDatasyncAction)).append("\n");
    sb.append("    writeDatasyncReply: ").append(toIndentedString(writeDatasyncReply)).append("\n");
    sb.append("    writeFilesyncAction: ").append(toIndentedString(writeFilesyncAction)).append("\n");
    sb.append("    writeFilesyncReply: ").append(toIndentedString(writeFilesyncReply)).append("\n");
    sb.append("    writeTransferMaxSize: ").append(toIndentedString(writeTransferMaxSize)).append("\n");
    sb.append("    writeTransferMultiple: ").append(toIndentedString(writeTransferMultiple)).append("\n");
    sb.append("    writeTransferSize: ").append(toIndentedString(writeTransferSize)).append("\n");
    sb.append("    writeUnstableAction: ").append(toIndentedString(writeUnstableAction)).append("\n");
    sb.append("    writeUnstableReply: ").append(toIndentedString(writeUnstableReply)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

